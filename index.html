<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Cryptogen - Encodeur / D√©codeur ADN | Convertir Texte en S√©quence ADN
    </title>
    <meta
      name="description"
      content="Cryptogen : outil gratuit pour encoder et d√©coder du texte en s√©quence ADN. Cr√©ez des messages secrets avec le code g√©n√©tique. √âditeur pixel art int√©gr√© pour dessiner dans l'ADN. Gratuit et sans inscription."
    />
    <meta
      name="keywords"
      content="encodeur ADN, d√©codeur ADN, cryptage ADN, s√©quence ADN, code g√©n√©tique, cryptage texte, message secret, pixel art ADN, g√©n√©tique, bioinformatique, outil p√©dagogique"
    />
    <meta name="author" content="Michawaro" />
    <meta
      name="robots"
      content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"
    />
    <meta
      name="google-site-verification"
      content="NkVG6etTdlVCQqPhDHrmvjWMF3mEupZmvNkQcgDYYGc"
    />
    <link rel="canonical" href="https://michawaro.github.io/secret-ig/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://michawaro.github.io/secret-ig/" />
    <meta
      property="og:title"
      content="Cryptogen - Encodeur / D√©codeur ADN | Convertir Texte en S√©quence ADN"
    />
    <meta
      property="og:description"
      content="Outil gratuit pour encoder et d√©coder du texte en s√©quence ADN. Cr√©ez des messages secrets avec le code g√©n√©tique. √âditeur pixel art int√©gr√©."
    />
    <meta
      property="og:image"
      content="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:locale" content="fr_FR" />
    <meta property="og:site_name" content="Cryptogen" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://michawaro.github.io/secret-ig/" />
    <meta name="twitter:title" content="Cryptogen - Encodeur / D√©codeur ADN" />
    <meta
      name="twitter:description"
      content="Outil gratuit pour encoder et d√©coder du texte en s√©quence ADN. Cr√©ez des messages secrets avec le code g√©n√©tique."
    />
    <meta
      name="twitter:image"
      content="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Cryptogen",
        "description": "Outil gratuit en ligne pour encoder et d√©coder du texte en s√©quence ADN. Cr√©ez des messages secrets avec le code g√©n√©tique. √âditeur pixel art int√©gr√© pour dessiner dans l'ADN.",
        "url": "https://michawaro.github.io/secret-ig/",
        "applicationCategory": "EducationalApplication",
        "operatingSystem": "Any",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "EUR"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "5",
          "ratingCount": "1"
        },
        "featureList": [
          "Encodeur de texte en s√©quence ADN",
          "D√©codeur de s√©quence ADN en texte",
          "√âditeur pixel art avec conversion ADN",
          "Export en format FASTA",
          "Interface intuitive et gratuite"
        ],
        "creator": {
          "@type": "Organization",
          "name": "Michawaro",
          "url": "https://michawaro.github.io/michawaro/"
        },
        "inLanguage": "fr"
      }
    </script>

    <link
      rel="icon"
      type="image/png"
      href="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <link
      rel="apple-touch-icon"
      href="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=Comfortaa:wght@400;500;600;700&family=Quicksand:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #8a9bb0 0%, #c4d9e8 100%);
        color: #222;
        min-height: 100vh;
        padding-bottom: 60px;
      }
      .container {
        max-width: 1440px;
        margin: 0 auto;
        padding: 40px 20px;
      }
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 180px 40px 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        min-height: 120px;
      }
      header > *:not(.header-logo) {
        display: block;
        width: 100%;
        max-width: 100%;
      }
      .header-logo {
        position: absolute;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: 150px;
        height: auto;
        cursor: pointer;
        transition: transform 0.3s ease, opacity 0.3s ease;
        z-index: 1;
      }
      .header-logo:hover {
        transform: translateY(-50%) scale(1.05);
        opacity: 0.9;
      }
      /* Styles pour l'image de la fabrique dans l'√©diteur Pixel Art */
      .pixel-art-image-container {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        flex-wrap: nowrap;
      }
      .pixel-art-grid-wrapper {
        flex: 1;
        min-width: 500px;
        width: 100%;
      }
      .pixel-grid-image-wrapper {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        flex-wrap: nowrap;
      }
      .pixel-art-illustration {
        flex-shrink: 0;
        max-width: 460px;
        width: auto;
        height: auto;
        align-self: flex-start;
        object-fit: contain;
      }
      /* Media query pour mobile en mode portrait */
      @media (max-width: 768px) and (orientation: portrait) {
        .pixel-art-image-container {
          flex-direction: column;
        }
        .pixel-art-grid-wrapper {
          min-width: 100%;
          width: 100%;
        }
        .pixel-grid-image-wrapper {
          flex-direction: column !important;
          flex-wrap: wrap;
        }
        .pixel-art-illustration {
          max-width: 100%;
          width: 100%;
          margin-top: 20px;
          align-self: center;
          order: 2;
        }
        #pixelGrid {
          order: 1;
        }
      }
      @media (max-width: 768px) {
        .pixel-art-image-container {
          flex-direction: column;
        }
        .pixel-art-grid-wrapper {
          min-width: 100%;
          width: 100%;
        }
        .pixel-grid-image-wrapper {
          flex-direction: column !important;
          flex-wrap: wrap;
          width: 100%;
        }
        .pixel-art-illustration {
          max-width: 100%;
          width: 100%;
          margin-bottom: 20px;
          align-self: center;
          order: 1;
        }
        #pixelGrid {
          order: 2;
          width: 100% !important;
          max-width: 100% !important;
          min-width: 100% !important;
        }
      }
      @media (max-width: 768px) {
        .container {
          padding: 15px 10px;
        }
        header {
          padding: 20px;
          min-height: auto;
        }
        .header-logo {
          position: static;
          transform: none;
          display: block;
          margin: 0 auto 20px auto;
          width: 120px;
        }
        .header-logo:hover {
          transform: scale(1.05);
        }
        header h1 {
          margin-top: 0;
          padding-right: 0;
          font-size: 2rem;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        header .subtitle {
          display: block;
          width: 100%;
          white-space: normal;
          word-wrap: break-word;
          overflow-wrap: break-word;
          font-size: 1rem;
          line-height: 1.5;
        }
        header p {
          display: block;
          width: 100%;
          white-space: normal;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        header > *:not(.header-logo) {
          width: 100%;
        }
        .section {
          width: 100%;
          max-width: 100%;
          padding: 20px 15px;
          margin-left: 0;
          margin-right: 0;
          box-sizing: border-box;
        }
      }
      h1 {
        font-size: 3rem;
        font-weight: 900;
        margin: 0 0 20px 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
        display: block;
        width: 100%;
      }
      .subtitle {
        font-size: 1.3rem;
        color: #666;
        margin: 0;
        font-weight: 400;
        line-height: 1.6;
        display: block;
        width: 100%;
      }
      .section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 40px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h2 {
        font-size: 2.4rem;
        font-weight: 800;
        margin: 0 0 30px 0;
        text-align: center;
        color: #333;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
      }
      textarea {
        width: 100%;
        height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        resize: vertical;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        line-height: 1.6;
      }
      textarea::placeholder {
        color: #999;
        opacity: 1;
      }
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      button {
        margin-top: 20px;
        padding: 16px 32px;
        font-size: 1.1rem;
        font-weight: 600;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
          1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
          1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
          0 0 5px rgba(0, 0, 0, 0.5);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        touch-action: manipulation;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      .output {
        margin-top: 30px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 12px;
        min-height: 80px;
        max-height: 400px;
        overflow-y: auto;
        font-size: 1.2rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 2;
        border: 2px solid #e0e0e0;
        font-family: "Courier New", monospace;
      }
      /* Message pour la fen√™tre de r√©sultats de d√©codage */
      #output:empty:before {
        content: "Les r√©sultats appara√Ætront ici, tu vas savoir ce qu'on souhaite te dire √† partir de cet ADN !";
        color: #999;
        font-style: italic;
      }
      /* Message pour la fen√™tre de r√©sultats d'encodage */
      #dnaOutput:empty:before {
        content: "Le r√©sultat appara√Ætra ici... Tu peux le copier-coller dans encodage pour tester que tout fonctionne puis envoyer ce message cod√© √† qui tu veux. Pour les textes √† trous, double-clique sur les mots que tu souhaites masquer.";
        color: #999;
        font-style: italic;
      }
      .word-space {
        background-color: #e0e0e0;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-short {
        background-color: #b3d9ff;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-medium {
        background-color: #b3ffb3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-long {
        background-color: #fff9b3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-verylong {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou {
        background-color: #ff6b6b !important;
        opacity: 0.7;
        cursor: pointer;
        position: relative;
      }
      .word-stop {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou:hover {
        opacity: 1;
      }
      .word-trou::after {
        content: "‚úï";
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ff6b6b;
        color: white;
        text-shadow: -0.3px -0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px -0.3px 0 rgba(0, 0, 0, 0.5), -0.3px 0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px 0.3px 0 rgba(0, 0, 0, 0.5), 0 0 0.5px rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }
      .trou-mode-active {
        background: #fff3cd !important;
        border: 2px solid #ffc107 !important;
      }
      #dnaInput {
        width: 100%;
        min-height: 160px;
        max-height: 400px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        background: white;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: border-color 0.3s ease;
        line-height: 1.6;
      }
      #dnaInput:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      #dnaInput:empty:before {
        content: attr(placeholder);
        color: #999;
        pointer-events: none;
      }
      /* Menu contextuel pour les modifications de s√©quence */
      #contextMenu {
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 8px 0;
        z-index: 10000;
        min-width: 180px;
        display: none;
      }
      #contextMenu .menu-item {
        padding: 10px 20px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 0.95rem;
      }
      #contextMenu .menu-item:hover {
        background-color: #f0f0f0;
      }
      #contextMenu .menu-item:active {
        background-color: #e0e0e0;
      }
      /* Style pour les nucl√©otides modifi√©s (blanc sur fond noir) */
      .nucleotide-modified {
        color: white !important;
        background-color: black !important;
        padding: 2px 1px;
        border-radius: 2px;
      }
      table {
        margin: 0 auto;
        width: 100%;
        max-width: 1000px;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
      }
      th,
      td {
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        border-right: 1px solid #eee;
        text-align: center;
        font-family: "Courier New", monospace;
        font-size: 0.95rem;
        width: 12.5%;
      }
      th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
          1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
          1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
          0 0 5px rgba(0, 0, 0, 0.5);
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }
      td:last-child,
      th:last-child {
        border-right: none;
      }
      tr:hover {
        background-color: #f8f9fa;
      }
      tr:last-child td {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <a
          href="https://michawaro.github.io/michawaro/"
          target="_blank"
          title="Aller sur la page Michawaro"
        >
          <img
            src="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
            alt="Logo Michawaro - Cryptogen Encodeur D√©codeur ADN"
            class="header-logo"
            width="150"
            height="150"
            onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"
          />
          <div
            class="header-logo"
            style="
              display: none;
              width: 150px;
              height: 150px;
              background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
              border-radius: 50%;
              position: relative;
              overflow: hidden;
            "
          >
            <div
              style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                color: white;
                font-weight: bold;
                z-index: 2;
                width: 85%;
                padding: 0;
                box-sizing: border-box;
              "
            >
              <div
                style="
                  font-size: 0.95rem;
                  margin-bottom: 3px;
                  line-height: 1.1;
                  white-space: nowrap;
                "
              >
                MICHAWARO
              </div>
              <div style="font-size: 0.65rem; color: #fce86e; line-height: 1.1">
                APPRENDRE, ENSEIGNER, PARTAGER
              </div>
            </div>
            <svg
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                opacity: 0.3;
              "
              viewBox="0 0 100 100"
              preserveAspectRatio="none"
            >
              <path
                d="M50,10 Q30,30 20,50 Q30,70 50,90 Q70,70 80,50 Q70,30 50,10"
                stroke="#8B4A9B"
                stroke-width="2"
                fill="none"
              />
              <path
                d="M50,15 Q35,30 25,50 Q35,70 50,85 Q65,70 75,50 Q65,30 50,15"
                stroke="#8B4A9B"
                stroke-width="1.5"
                fill="none"
              />
            </svg>
          </div>
        </a>
        <h1>Cryptogen - Encodeur / D√©codeur ADN</h1>
        <p class="subtitle">
          Colle une s√©quence ADN ou un texte, et encode ou d√©code avec le m√™me
          code g√©n√©tique.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Mode d'emploi de l'encodeur dans
          <a
            href="https://youtu.be/752HGS405eY"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >cette vid√©o</a
          >. Des exemples d'utilisation seront ajout√©s sur
          <a
            href="https://michawaro.github.io/michawaro/"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >la page Michawaro</a
          >.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Pour des retours ou suggestions vous pouvez
          <a
            href="mailto:michawaro.mail@gmail.com"
            style="
              color: #667eea;
              text-decoration: underline;
              cursor: pointer;
              transition: color 0.2s ease;
            "
            onmouseover="this.style.color='#764ba2'"
            onmouseout="this.style.color='#667eea'"
            >me contacter</a
          >.
        </p>
      </header>

      <div class="section">
        <h2>Pr√©requis</h2>
        <div
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 30px;
          "
        >
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 25px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <h3
              style="
                margin: 0 0 20px 0;
                color: #333;
                font-size: 1.5rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Quelques notions sur l'ADN
            </h3>
            <div
              id="notionsADNButtons"
              style="display: flex; flex-direction: column; gap: 10px"
            >
              <button
                onclick="window.open('https://www.canva.com/design/DAG8F9XFrVY/dBv3GvqcVJZxjU3WLcnF3w/view?utm_content=DAG8F9XFrVY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h27ee868e96', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                Une mol√©cule organis√©e...
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ... contenant une information prot√©g√©e...
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ... dont l'expression conduit √† la synth√®se de prot√©ines.
              </button>
            </div>
          </div>
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 25px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <h3
              style="
                margin: 0 0 20px 0;
                color: #333;
                font-size: 1.5rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Je me teste
            </h3>
            <div
              id="testButtons"
              style="display: flex; flex-direction: column; gap: 10px"
            >
              <button
                onclick="window.open('https://michawaro.github.io/cryptogen/Quiz/2nde/', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                2nde
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                1ere
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                Terminale
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          Encodage - Transformez vos phrases ou vos dessins en s√©quences d'ADN !
        </h2>
        <p
          style="
            margin-bottom: 15px;
            color: #333;
            font-size: 1.76rem;
            font-weight: 500;
            line-height: 1.6;
            text-align: center;
          "
        >
          Ce que je souhaite encoder sous forme d'une s√©quence ADN :
        </p>
        <textarea
          id="textInput"
          placeholder="Ecris, colle ou importe un texte que tu souhaites encoder dans de l'ADN. Anecdote : il est aujourd'hui possible d'encapsuler l'ADN dans des nanobilles de silice. En les stockant dans des capsules en acier inoxydable, on estime pouvoir obtenir une dur√©e de vie de 50.000 ans. Source : Acad√©mie des technologies - Wikipedia"
        ></textarea>
        <div
          style="
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
          "
        >
          <button
            onclick="encodeText()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/1covqkpg610vvsmnpvhgd/Bouton-Encoder.png?rlkey=wkbzvci3ac9fp7vg4ghfjb7cw&st=zgk9jkfz&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Texte
          </button>
          <button
            id="trouModeBtn"
            onclick="toggleTrouMode()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/x94k24wjgsy5qx80vzn76/Bouton-Trous.png?rlkey=08oskttv9edx7tks6e3fruohh&st=wt2nbmka&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Texte √† trous
          </button>
        </div>
        <div
          style="
            margin-top: 20px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
          "
        >
          <span
            style="
              color: #333;
              font-size: 1.6rem;
              font-weight: 500;
              text-align: center;
              display: block;
              width: 100%;
            "
          >
            Je pr√©f√®re dessiner et encoder un dessin en s√©quence ADN :
          </span>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              flex-wrap: wrap;
            "
          >
            <button
              onclick="openPixelArtEditor()"
              id="pixelArtBtn"
              style="
                position: relative;
                overflow: hidden;
                border: 2px solid #333;
              "
            >
              <span
                style="
                  position: relative;
                  z-index: 2;
                  color: white;
                  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
                  font-weight: bold;
                "
                >Pixel art</span
              >
              <div
                id="pixelArtMosaic"
                style="
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  z-index: 1;
                  display: grid;
                  grid-template-columns: repeat(8, 1fr);
                  grid-template-rows: repeat(4, 1fr);
                  gap: 1px;
                  background: #9b59b6;
                "
              ></div>
            </button>
            <button
              id="exportBtn"
              onclick="openExportModal()"
              style="
                background-image: url('https://www.dropbox.com/scl/fi/914wi5wvt59l7dy4j7onz/Bouton-sauvegarder.png?rlkey=g1xvkbw2orc5dxthgo5wkofpf&st=jy6l5f3n&raw=1');
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                color: #fff;
                text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                  1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                  1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                  0 0 5px rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(255, 255, 255, 0.3);
                display: none;
              "
            >
              T√©l√©charger
            </button>
          </div>
        </div>
        <button
          id="copyBtn"
          onclick="copyDNAWithTrous()"
          style="margin-left: 10px; background: #51cf66; display: none"
        >
          Copier la s√©quence
        </button>
        <p
          id="dnaOutputLabel"
          style="
            display: none;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #333;
            font-size: 1.6rem;
            font-weight: 500;
            line-height: 1.6;
            text-align: center;
          "
        >
          Voici une s√©quence ADN contenant ton texte/dessin, tu peux la
          t√©l√©charger :
        </p>
        <div class="output" id="dnaOutput"></div>
      </div>

      <div class="section">
        <h2>D√©codage</h2>
        <div style="margin-bottom: 15px; text-align: center">
          <button
            onclick="openImportModal()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/cmxmx7gp6ipkgbnkwo7ul/Bouton-ADN.png?rlkey=de5pm9v22723web0s3v5ykp38&st=4s2y7aj8&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
              margin-right: 10px;
            "
          >
            Importer de l'ADN
          </button>
          <input
            type="file"
            id="ediFileInput"
            accept=".edi"
            style="display: none"
            onchange="importEDIFile(event)"
          />
          <input
            type="file"
            id="fastaFileInput"
            accept=".fasta,.fa,.fas"
            style="display: none"
            onchange="importFASTAFile(event)"
          />
          <button
            onclick="loadTestTextSequence()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/evqozc3atpj7k98f51fnt/Bouton-Texte.png?rlkey=g3bm34kfxz95fj4haxsitgt1s&st=31grtgcr&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Tester texte üìñ
          </button>
          <button
            onclick="loadTestImageSequence()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/l1dpigpe88rl2pyg3f07e/Bouton-Image.png?rlkey=ng5n1wt2tkw3cbb07r82k9ope&st=c8gkzhsn&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Tester image ‚õ∞Ô∏è
          </button>
          <button
            onclick="openScenarioVideo()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/aaajr0x4rr041t2w1aq0c/Bouton-Sc-nario.png?rlkey=sjlonljrq5xk8yti2fkbdr50l&st=r8ozrln6&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
              margin-left: 10px;
            "
          >
            Sc√©nario
          </button>
        </div>
        <div
          id="dnaInput"
          contenteditable="true"
          placeholder="Ecris ou colle ici une s√©quence d'ADN. L'ADN contient des informations cod√©es sous forme de s√©quence de nucl√©otides. Peut-√™tre qu'un message est cach√© dans la s√©quence que tu vas √©tudier ?"
        ></div>
        <div id="contextMenu">
          <div class="menu-item" data-action="substitution">Substitution</div>
          <div class="menu-item" data-action="addition">Addition</div>
          <div class="menu-item" data-action="suppression">Suppression</div>
        </div>
        <div style="text-align: center; margin-top: 20px">
          <button onclick="decodeDNA()">D√©coder</button>
        </div>
        <p
          style="
            margin-top: 15px;
            margin-bottom: 10px;
            color: #666;
            font-style: italic;
            text-align: center;
          "
        >
          Dans le cas o√π certains mots s'affichent sous forme de s√©quence de
          nucl√©otides, double cliquez dessus pour les d√©chiffrer.
        </p>
        <div class="output" id="output"></div>
      </div>

      <div class="section">
        <h2>Code g√©n√©tique fictif - Triplet de nucl√©otides / texte</h2>
        <div style="margin-bottom: 20px; text-align: center">
          <button
            onclick="exportGeneticCode()"
            style="margin-right: 10px; background: #51cf66"
          >
            Exporter CSV
          </button>
          <label for="csvFileInput" style="display: inline-block">
            <button
              onclick="document.getElementById('csvFileInput').click()"
              style="background: #4dabf7"
            >
              Importer CSV
            </button>
            <input
              type="file"
              id="csvFileInput"
              accept=".csv"
              style="display: none"
              onchange="importGeneticCode(event)"
            />
          </label>
        </div>
        <p
          style="
            margin-top: 10px;
            margin-bottom: 15px;
            color: #666;
            font-style: italic;
            text-align: center;
            font-size: 0.9rem;
          "
        >
          L'import CSV permet √† chaque utilisateur de personnaliser
          temporairement le code g√©n√©tique pour sa session.
        </p>
        <table>
          <thead>
            <tr>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
            </tr>
          </thead>
          <tbody id="codeTable"></tbody>
        </table>
      </div>
    </div>

    <!-- Fen√™tre modale pour le pixel art -->
    <div
      id="pixelArtModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1001;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 20px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 95%;
          max-height: 95vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h2 style="margin: 0; color: #667eea">
            √âditeur Pixel Art : Enregistre ton dessin dans l'ADN !<br />
            Chaque pixel correspond √† un triplet de nucl√©otides.
          </h2>
          <div style="display: flex; gap: 10px">
            <button
              id="savePixelArtBtn"
              onclick="savePixelArt()"
              style="
                background: #51cf66;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1.2rem;
                touch-action: manipulation;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
              "
            >
              üíæ Enregistrer dans l'ADN
            </button>
            <button
              id="closePixelArtModal"
              style="
                background: #ff6b6b;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1.2rem;
                touch-action: manipulation;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
              "
            >
              ‚úï Fermer
            </button>
          </div>
        </div>
        <div id="pixelArtContent"></div>
      </div>
    </div>

    <!-- Fen√™tre modale pour choisir le nom de fichier et le r√©pertoire -->
    <div
      id="saveFileModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1003;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Enregistrer le fichier</h3>
          <button
            id="closeSaveFileModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ‚úï
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <label
            for="fileNameInput"
            style="
              display: block;
              margin-bottom: 8px;
              font-weight: bold;
              color: #333;
            "
          >
            Nom du fichier :
          </label>
          <input
            type="text"
            id="fileNameInput"
            value="sequence_encod√©e"
            style="
              width: 100%;
              padding: 10px;
              border: 2px solid #ddd;
              border-radius: 6px;
              font-size: 1rem;
              box-sizing: border-box;
            "
          />
          <p
            id="fileExtensionInfo"
            style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem"
          >
            Extension : .fasta
          </p>
          <button
            id="chooseDirectoryBtn"
            onclick="chooseDirectory()"
            style="
              width: 100%;
              padding: 12px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1rem;
              font-weight: bold;
            "
          >
            üìÅ Choisir le r√©pertoire
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            <span id="directoryInfo"
              >Le fichier sera t√©l√©charg√© dans le r√©pertoire par d√©faut de votre
              navigateur.</span
            >
          </p>
          <div style="display: flex; gap: 10px; margin-top: 20px">
            <button
              id="confirmSaveBtn"
              onclick="confirmSaveFile()"
              style="
                flex: 1;
                padding: 12px;
                background: #51cf66;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: bold;
              "
            >
              üíæ Enregistrer
            </button>
            <button
              onclick="closeSaveFileModal()"
              style="
                flex: 1;
                padding: 12px;
                background: #ff6b6b;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: bold;
              "
            >
              Annuler
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Fen√™tre modale pour choisir la taille -->
    <div
      id="sizeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 400px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea" id="sizeModalTitle">
            Choisir la taille
          </h3>
          <button
            id="closeSizeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ‚úï
          </button>
        </div>
        <div
          id="sizeModalContent"
          style="
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
          "
        ></div>
      </div>
    </div>

    <!-- Fen√™tre modale pour choisir le format d'import -->
    <div
      id="importModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Choisir le format d'import</h3>
          <button
            id="closeImportModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ‚úï
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <button
            onclick="openImportFormat('edi')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            üìÑ Format .edi
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            Format simple : une seule ligne de s√©quence ADN sans en-t√™te. Id√©al
            pour les s√©quences courtes.
          </p>
          <button
            onclick="openImportFormat('fasta')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            üß¨ Format .fasta
          </button>
          <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem">
            Format standard en bioinformatique : commence par un en-t√™te (ligne
            commen√ßant par ">") suivi de la s√©quence ADN sur une ou plusieurs
            lignes. Plus lisible pour les longues s√©quences.
          </p>
        </div>
      </div>
    </div>

    <!-- Fen√™tre modale pour choisir le format d'export -->
    <div
      id="exportModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Choisir le format d'export</h3>
          <button
            id="closeExportModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ‚úï
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <button
            onclick="openExportFormat('edi')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            üìÑ Format .edi
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            Format simple : une seule ligne de s√©quence ADN sans en-t√™te. Id√©al
            pour les s√©quences courtes.
          </p>
          <button
            onclick="openExportFormat('fasta')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            üß¨ Format .fasta
          </button>
          <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem">
            Format standard en bioinformatique : commence par un en-t√™te (ligne
            commen√ßant par ">") suivi de la s√©quence ADN sur une ou plusieurs
            lignes. Plus lisible pour les longues s√©quences.
          </p>
        </div>
      </div>
    </div>

    <!-- Fen√™tre modale pour le d√©codage interactif -->
    <div
      id="decodeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h2 style="margin: 0; color: #667eea">D√©codage interactif</h2>
          <button
            id="closeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1.2rem;
            "
          >
            ‚úï Fermer
          </button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const geneticCode = {
        ATG: "START",
        AAA: "A",
        // Ordre alphab√©tique des triplets
        // A : 1 triplet
        AAC: "√Ä",
        AAG: "√Ç",
        // B : 1 triplet
        AAT: "B",
        // C : 2 triplets
        ACA: "C",
        ACC: "√á",
        // D : 2 triplets
        ACG: "D",
        // E : 1 triplet
        ACT: "E",
        AGC: "≈í",
        // √â (√© en majuscule) : 1 triplet
        AGG: "√â",
        // √à (√® en majuscule) : 1 triplet
        AGT: "√à",
        // √ä (√™ en majuscule) : 1 triplet
        ATA: "√ä",
        // √ã (√´ en majuscule) : 1 triplet
        ATC: "√ã",
        // F : 2 triplets
        ATT: "F",
        CAA: "F",
        // G : 2 triplets
        CAC: "G",
        CAG: "G",
        // H : 2 triplets
        CAT: "H",
        CCA: "H",
        // I : 1 triplet
        CCC: "I",
        // √è (√Ø en majuscule) : 1 triplet
        CCG: "√è",
        // J : 2 triplets
        CCT: "J",
        CGA: "J",
        // K : 2 triplets
        CGC: "K",
        CGG: "K",
        // L : 2 triplets
        CGT: "L",
        CTA: "L",
        // M : 2 triplets
        CTC: "M",
        CTG: "M",
        // N : 2 triplets
        CTT: "N",
        GAA: "N",
        // O : 2 triplets
        GAC: "O",
        GAG: "O",
        // P : 2 triplets
        GAT: "P",
        GCA: "P",
        // Q : 2 triplets
        GCC: "Q",
        GCG: "Q",
        // R : 2 triplets
        GCT: "R",
        GGA: "R",
        // S : 2 triplets
        GGC: "S",
        GGT: "S",
        // T : 2 triplets
        GTA: "T",
        GTC: "T",
        // U : 2 triplets
        GTG: "U",
        GTT: "U",
        // V : 2 triplets
        TAC: "V",
        TAT: "V",
        // W : 2 triplets
        TCA: "W",
        TCC: "W",
        // X : 2 triplets
        TCG: "X",
        TCT: "X",
        // Point (fin de phrase) - uniquement les 3 stop codons classiques
        TAA: ".",
        TAG: ".",
        TGA: ".",
        // Utiliser les triplets restants pour des redondances
        TGC: "Y", // Y : 1 triplet
        TGG: "Z", // Z : 1 triplet
        // Caract√®res sp√©ciaux (derniers triplets)
        TTA: ",", // Virgule
        TTC: "'", // Apostrophe
        TTG: ",", // Virgule (tous types)
        TTT: " ", // Espace
      };

      const reverseCode = {};
      for (let [codon, char] of Object.entries(geneticCode)) {
        if (char !== "START") {
          if (!reverseCode[char]) reverseCode[char] = [];
          reverseCode[char].push(codon);
        }
      }

      // Variables pour le mode "encodage √† trou"
      let trouModeActive = false;
      let selectedWordIndices = new Set(); // Indices des mots s√©lectionn√©s (0-based)
      let currentWordPositions = []; // Positions des mots dans la s√©quence actuelle

      // Fonction pour activer/d√©sactiver le mode "√† trou"
      function toggleTrouMode() {
        trouModeActive = !trouModeActive;
        const btn = document.getElementById("trouModeBtn");
        const output = document.getElementById("dnaOutput");
        const textInput = document.getElementById("textInput");

        if (trouModeActive) {
          btn.classList.add("trou-mode-active");
          btn.textContent = "Double-cliquez sur les mots";
          // R√©encoder pour permettre la s√©lection
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encod√©, afficher un message
            output.innerHTML =
              '<span style="color: #666; font-style: italic;">Veuillez d\'abord encoder un texte pour utiliser le mode "√† trou".</span>';
          }
        } else {
          btn.classList.remove("trou-mode-active");
          btn.textContent = "Texte √† trou";
          // R√©encoder pour enlever les s√©lections
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encod√©, vider l'affichage
            output.innerHTML = "";
          }
        }
      }

      // Marqueur sp√©cial pour les positions "√† trou" : TGGTGG (double stop codon)
      const TROU_MARKER = "TGGTGG";

      // Fonction pour encoder les positions des mots s√©lectionn√©s
      function encodeTrouPositions(indices) {
        if (indices.size === 0) return "";
        // Format: TGGTGG (marqueur) + positions encod√©es en base 4, longueur fixe 4 (A=0, T=1, C=2, G=3)
        // Longueur fixe √©vite toute ambigu√Øt√© lors du d√©codage (pas besoin de s√©parateur)
        const positions = Array.from(indices).sort((a, b) => a - b);
        let encoded = TROU_MARKER; // Marqueur de d√©but

        for (let pos of positions) {
          let digits = [];
          let n = pos;
          // Encoder sur 4 digits base 4
          for (let i = 0; i < 4; i++) {
            digits.unshift(n % 4);
            n = Math.floor(n / 4);
          }
          const dnaDigits = digits.map((d) => ["A", "T", "C", "G"][d]).join("");
          encoded += dnaDigits;
        }

        return encoded;
      }

      // Fonction pour d√©coder les positions des mots √† trou
      function decodeTrouPositions(dna) {
        const indices = new Set();
        // Chercher le marqueur TGGTGG
        const startIdx = dna.indexOf(TROU_MARKER);
        if (startIdx === -1) return indices;

        // Extraire la partie apr√®s le marqueur (chaque position = 4 bases cod√©es)
        const encoded = dna.substring(startIdx + TROU_MARKER.length);
        for (let i = 0; i + 4 <= encoded.length; i += 4) {
          const chunk = encoded.substring(i, i + 4);
          let pos = 0;
          for (let j = 0; j < chunk.length; j++) {
            const digit = ["A", "T", "C", "G"].indexOf(chunk[j]);
            if (digit === -1) {
              pos = null;
              break;
            }
            pos = pos * 4 + digit;
          }
          if (pos !== null) {
            indices.add(pos);
          }
        }

        return indices;
      }

      // Fonction pour obtenir la classe CSS selon la longueur du mot
      function getWordClass(length) {
        if (length <= 4) return "word-short";
        if (length <= 6) return "word-medium";
        if (length <= 9) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer le texte selon la longueur des mots
      function colorizeText(text, wordToDNA = null) {
        const words = text.split(/(\s+)/);
        let html = "";
        for (let word of words) {
          if (word.trim() === "") {
            // Espace
            html += `<span class="word-space">${word}</span>`;
          } else {
            const length = word.length;
            const className = getWordClass(length);
            const tooltip =
              wordToDNA && wordToDNA[word] ? ` title="${wordToDNA[word]}"` : "";
            html += `<span class="${className}"${tooltip}>${word}</span>`;
          }
        }
        return html;
      }

      // Fonction pour d√©coder une s√©quence ADN en texte
      function decodeDNASequence(dnaSequence) {
        let decoded = "";
        for (let i = 0; i <= dnaSequence.length - 3; i += 3) {
          const codon = dnaSequence.substring(i, i + 3);
          const decodedChar = geneticCode[codon];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            if (decodedChar === "√©") displayChar = "√â";
            if (decodedChar === "√®") displayChar = "√à";
            if (decodedChar === "√™") displayChar = "√ä";
            if (decodedChar === "√´") displayChar = "√ã";
            if (decodedChar === "√Ø") displayChar = "√è";
            decoded += displayChar;
          }
        }
        return decoded;
      }

      // Fonction pour colorer la s√©quence ADN selon les mots (pour le d√©codage)
      function colorizeDNAForDecode(dna) {
        if (!dna || dna.length === 0) return "";

        // V√©rifier s'il y a un marqueur "√† trou" (TGGTGG)
        const markerIndex = dna.indexOf(TROU_MARKER);
        let sequenceToColorize = dna;
        let markerAndPositions = "";

        if (markerIndex !== -1) {
          // S√©parer la s√©quence principale et le marqueur avec les positions
          sequenceToColorize = dna.substring(0, markerIndex);
          markerAndPositions = dna.substring(markerIndex);
        }

        let html = "";
        let i = 0;
        const startIndex = sequenceToColorize.indexOf("ATG");

        if (startIndex === -1) {
          // Pas de ATG, commencer au d√©but
          i = 0;
        } else {
          // Ajouter tout ce qui pr√©c√®de ATG et ATG lui-m√™me
          html += `<span>${sequenceToColorize.substring(
            0,
            startIndex + 3
          )}</span>`;
          i = startIndex + 3;
        }

        let currentWordStart = i;
        let inWord = true;

        // Traiter toute la s√©quence sans s'arr√™ter aux codons stop
        while (i <= sequenceToColorize.length - 3) {
          const codon = sequenceToColorize.substring(i, i + 3);

          if (codon === "TTT") {
            // Espace
            if (inWord) {
              // Finir le mot pr√©c√©dent
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-space">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Codon stop = point (mais continuer apr√®s)
            if (inWord) {
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else {
            i += 3;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord && i > currentWordStart) {
          const wordLength = i - currentWordStart;
          const className = getNucleotideClass(wordLength);
          const wordDNA = sequenceToColorize.substring(currentWordStart, i);
          const decodedWord = decodeDNASequence(wordDNA);
          const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
          html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
        }

        // Ajouter le reste de la s√©quence (ce qui reste apr√®s le dernier triplet complet)
        if (i < sequenceToColorize.length) {
          html += `<span>${sequenceToColorize.substring(i)}</span>`;
        }

        // Ajouter le marqueur et les positions "√† trou" s'ils existent
        if (markerAndPositions) {
          html += `<span style="color: #999; font-size: 0.9em;">${markerAndPositions}</span>`;
        }

        return html;
      }

      // Fonction pour coloriser le textarea de d√©codage
      function colorizeDNAInput() {
        const dnaInput = document.getElementById("dnaInput");
        let rawText = dnaInput.getAttribute("data-full-sequence");
        if (!rawText) {
          rawText = dnaInput.innerText || dnaInput.textContent || "";
        }

        // Si on d√©tecte un marqueur "√† trou", on masque visuellement la partie apr√®s le marqueur
        const markerIndex = rawText.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          const visible = rawText.substring(0, markerIndex);
          // Stocker la s√©quence compl√®te pour le d√©codage
          dnaInput.setAttribute("data-full-sequence", rawText);
          // Afficher uniquement la partie visible
          dnaInput.textContent = visible;
          // Repartir du visible pour le coloriage
          rawText = visible;
        }

        const cleaned = rawText.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length === 0) {
          if (text.length === 0) {
            dnaInput.innerHTML = "";
          }
          return;
        }

        const colored = colorizeDNAForDecode(cleaned);

        // Appliquer le style aux nucl√©otides modifi√©s
        const modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );
        let finalHTML = colored;

        if (modifiedRanges.length > 0) {
          // Cr√©er un √©l√©ment temporaire pour manipuler le HTML
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = colored;

          // Parcourir tous les n≈ìuds texte et appliquer le style aux positions modifi√©es
          const walker = document.createTreeWalker(
            tempDiv,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );

          let textPos = 0;
          const nodesToWrap = [];

          let node;
          while ((node = walker.nextNode())) {
            const nodeText = node.textContent;
            const nodeStart = textPos;
            const nodeEnd = textPos + nodeText.length;

            // V√©rifier si cette portion chevauche une plage modifi√©e
            for (let range of modifiedRanges) {
              if (nodeEnd > range.start && nodeStart < range.end) {
                // Il y a un chevauchement
                const overlapStart = Math.max(0, range.start - nodeStart);
                const overlapEnd = Math.min(
                  nodeText.length,
                  range.end - nodeStart
                );

                if (overlapStart < overlapEnd) {
                  nodesToWrap.push({
                    node: node,
                    start: overlapStart,
                    end: overlapEnd,
                  });
                }
              }
            }

            textPos = nodeEnd;
          }

          // Appliquer les modifications (en ordre inverse pour pr√©server les indices)
          nodesToWrap.reverse().forEach(({ node, start, end }) => {
            const parent = node.parentNode;
            const beforeText = node.textContent.substring(0, start);
            const modifiedText = node.textContent.substring(start, end);
            const afterText = node.textContent.substring(end);

            // Cr√©er les nouveaux n≈ìuds
            if (beforeText) {
              parent.insertBefore(document.createTextNode(beforeText), node);
            }

            const modifiedSpan = document.createElement("span");
            modifiedSpan.className = "nucleotide-modified";
            modifiedSpan.textContent = modifiedText;
            parent.insertBefore(modifiedSpan, node);

            if (afterText) {
              parent.insertBefore(document.createTextNode(afterText), node);
            }

            parent.removeChild(node);
          });

          finalHTML = tempDiv.innerHTML;
        }

        // Ne mettre √† jour que si le contenu a chang√© pour √©viter les probl√®mes de curseur
        if (dnaInput.innerHTML !== finalHTML) {
          dnaInput.innerHTML = finalHTML;
        }
      }

      function decodeDNA() {
        const dnaInput = document.getElementById("dnaInput");
        // R√©cup√©rer la s√©quence compl√®te depuis l'attribut data si elle existe
        // Sinon utiliser le texte du champ (pour les cas o√π l'utilisateur tape manuellement)
        let rawInput = dnaInput.getAttribute("data-full-sequence");
        if (!rawInput) {
          rawInput = dnaInput.innerText || dnaInput.textContent || "";
        }
        // Nettoyer pour le d√©codage (enlever tout sauf A, T, C, G)
        let input = rawInput.toUpperCase().replace(/[^ATCG]/g, "");

        // D√©tecter si c'est une image pixel art (14700 ou 14703 nucl√©otides)
        // 14700 = 4900 triplets pour une grille 70x70 (palette classique par d√©faut)
        // 14703 = 1 triplet de palette + 4900 triplets pour une grille 70x70
        if (input.length === 14700 || input.length === 14703) {
          // C'est une image pixel art, ouvrir l'√©diteur avec cette s√©quence
          loadPixelArtFromSequence(input);
          return;
        }

        // Extraire les positions "√† trou" AVANT de retirer le marqueur (chercher TGGTGG)
        const trouIndices = decodeTrouPositions(input);

        // Retirer le marqueur et les positions de la s√©quence √† d√©coder
        const markerIndex = input.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          input = input.substring(0, markerIndex);
        }

        const output = document.getElementById("output");
        output.innerHTML = "";
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          output.textContent = "Aucun codon START (ATG) trouv√©.";
          return;
        }

        // D√©coder le message et cr√©er la correspondance mot -> s√©quence ADN
        const words = []; // Liste des mots (d√©cod√©s ou ADN)
        const wordToDNA = {}; // Correspondance mot -> s√©quence ADN
        let currentWord = "";
        let currentWordDNA = "";
        let wordIndex = 0; // Index du mot actuel
        let foundStopCodon = false; // Indicateur si on a trouv√© un codon stop

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // D'abord, finaliser et ajouter le mot actuel s'il existe
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "√† trou" : garder la s√©quence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : d√©coder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
            }

            // R√©initialiser IMM√âDIATEMENT pour √©viter que le point soit int√©gr√© au mot suivant
            currentWord = "";
            currentWordDNA = "";

            // Ignorer les codons stop cons√©cutifs en sautant directement au prochain codon non-stop
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3; // Sauter ce codon stop aussi
              } else {
                break; // Prochain codon n'est pas un stop, continuer normalement
              }
            }

            // Ajouter un point seulement si le dernier √©l√©ment ajout√© n'est pas d√©j√† un point
            let shouldAddPoint = true;
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              // Ne pas ajouter de point si le dernier √©l√©ment est d√©j√† un point
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                shouldAddPoint = false;
              }
            }

            if (shouldAddPoint) {
              words.push({ type: "punctuation", content: "." });
            }
            foundStopCodon = true;
            // CONTINUER dans la boucle pour traiter le prochain codon (qui sera le d√©but du mot suivant)
            continue;
          }

          if (codon === "TTT") {
            // Espace
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "√† trou" : garder la s√©quence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : d√©coder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
              currentWord = "";
              currentWordDNA = "";
            }
            // Ne pas ajouter d'espace si le dernier √©l√©ment est d√©j√† un point (√©vite l'espace entre point et mot suivant)
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                // Ne pas ajouter d'espace apr√®s un point
                wordIndex++; // Passer au mot suivant quand m√™me
                continue;
              }
            }
            words.push({ type: "space", content: " " });
            wordIndex++; // Passer au mot suivant
          } else {
            const decodedChar = geneticCode[codon];
            if (decodedChar && decodedChar !== "START") {
              // Forcer les minuscules accentu√©es √† s'afficher en majuscules
              let displayChar = decodedChar;
              if (decodedChar === "√©") displayChar = "√â";
              if (decodedChar === "√®") displayChar = "√à";
              if (decodedChar === "√™") displayChar = "√ä";
              if (decodedChar === "√´") displayChar = "√ã";
              if (decodedChar === "√Ø") displayChar = "√è";

              currentWordDNA += codon;
              // Si ce mot est "√† trou", ne pas d√©coder
              if (!trouIndices.has(wordIndex)) {
                currentWord += displayChar;
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe (m√™me apr√®s un codon stop, car on peut avoir plusieurs phrases)
        // Mais seulement si on n'a pas d√©j√† trait√© un codon stop √† la fin qui aurait vid√© currentWord
        if (currentWord || currentWordDNA) {
          // V√©rifier si le dernier codon de la s√©quence est un stop
          const lastCodon = input.substring(input.length - 3);
          const isLastCodonStop = ["TAA", "TAG", "TGA"].includes(lastCodon);

          // Si le dernier codon est un stop, il a d√©j√† √©t√© trait√© dans la boucle
          // et le mot a d√©j√† √©t√© ajout√©, donc on ne doit pas l'ajouter √† nouveau
          if (!isLastCodonStop) {
            if (trouIndices.has(wordIndex)) {
              // Mot "√† trou" : garder la s√©quence ADN
              words.push({
                type: "trou",
                content: currentWordDNA,
                dna: currentWordDNA,
              });
            } else {
              // Mot normal : d√©coder
              if (currentWord) {
                wordToDNA[currentWord] = currentWordDNA;
                words.push({
                  type: "normal",
                  content: currentWord,
                  dna: currentWordDNA,
                });
              }
            }
          }
        }

        // Fonction pour v√©rifier si une cha√Æne est une s√©quence ADN pure
        function isDNASequence(str) {
          return /^[ATCG]+$/i.test(str) && str.length >= 3;
        }

        // Afficher le texte d√©cod√© avec les mots "√† trou" en s√©quence ADN
        let html = "";
        for (let word of words) {
          if (word.type === "space") {
            html += `<span class="word-space">${word.content}</span>`;
          } else if (word.type === "punctuation") {
            // Les points doivent avoir la couleur d'arri√®re-plan rose pastel
            html += `<span class="word-stop">${word.content}</span>`;
          } else if (word.type === "trou") {
            // Afficher la s√©quence ADN avec double-clic
            html += `<span class="word-trou decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ff6b6b; padding: 4px 6px; border-radius: 4px; cursor: pointer; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;" title="Double-cliquez pour d√©coder">${word.content}</span>`;
          } else {
            // Mot normal - v√©rifier si c'est une s√©quence ADN pure
            if (isDNASequence(word.content)) {
              html += `<span class="decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ffb3d9; padding: 4px 6px; border-radius: 4px; cursor: pointer; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;" title="Double-cliquez pour d√©coder">${word.content}</span>`;
            } else {
              const length = word.content.length;
              const className = getWordClass(length);
              const tooltip = wordToDNA[word.content]
                ? ` title="${wordToDNA[word.content]}"`
                : "";
              html += `<span class="${className}"${tooltip}>${word.content}</span>`;
            }
          }
        }

        output.innerHTML = html;

        // Ajouter les √©v√©nements double-clic/double-tap sur les s√©quences ADN
        // Variable globale pour le double-tap (partag√©e entre tous les spans)
        if (!window.lastDecodeTap) {
          window.lastDecodeTap = { time: 0, target: null };
        }

        output.querySelectorAll(".decode-dna").forEach((span) => {
          // Emp√™cher la s√©lection de texte sur mobile
          span.addEventListener(
            "touchstart",
            function (e) {
              // Si c'est un double-tap potentiel, emp√™cher la s√©lection
              const currentTime = new Date().getTime();
              const timeSinceLastTap = currentTime - window.lastDecodeTap.time;
              if (
                timeSinceLastTap < 300 &&
                window.lastDecodeTap.target === this
              ) {
                e.preventDefault();
              }
            },
            { passive: false }
          );

          // Double-clic pour desktop
          span.addEventListener("dblclick", function (e) {
            e.preventDefault();
            const dnaSequence = this.getAttribute("data-dna");
            openDecodeModal(dnaSequence, this);
          });

          // Double-tap pour mobile/tactile
          span.addEventListener(
            "touchend",
            function (e) {
              const currentTime = new Date().getTime();
              const timeSinceLastTap = currentTime - window.lastDecodeTap.time;

              // V√©rifier si c'est un double-tap sur le m√™me √©l√©ment
              if (
                timeSinceLastTap < 300 &&
                timeSinceLastTap > 0 &&
                window.lastDecodeTap.target === this
              ) {
                // Double tap d√©tect√©
                e.preventDefault();
                e.stopPropagation();

                // Annuler toute s√©lection de texte
                if (window.getSelection) {
                  window.getSelection().removeAllRanges();
                }

                const dnaSequence = this.getAttribute("data-dna");
                openDecodeModal(dnaSequence, this);

                // R√©initialiser pour √©viter les triple-taps
                window.lastDecodeTap.time = 0;
                window.lastDecodeTap.target = null;
              } else {
                // Premier tap
                window.lastDecodeTap.time = currentTime;
                window.lastDecodeTap.target = this;
              }
            },
            { passive: false }
          );
        });
      }

      // Fonction pour ouvrir la modale de d√©codage interactif
      function openDecodeModal(dnaSequence, originalSpan = null) {
        const modal = document.getElementById("decodeModal");
        const modalContent = document.getElementById("modalContent");

        // Nettoyer la s√©quence (enlever tout sauf A, T, C, G)
        const cleaned = dnaSequence.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length < 3) {
          alert("S√©quence ADN trop courte pour √™tre d√©cod√©e.");
          return;
        }

        // Stocker la r√©f√©rence au span original pour pouvoir le remplacer
        window.modalOriginalSpan = originalSpan;
        window.modalDNASequence = cleaned;

        // R√©cup√©rer le mot d√©j√† saisi s'il existe (pour pr√©remplir)
        let existingWord = "";
        if (originalSpan && originalSpan.classList.contains("decode-filled")) {
          existingWord = originalSpan.textContent || "";
        }

        // Diviser en triplets et d√©coder
        const triplets = [];
        const decodedChars = [];
        let correctWord = ""; // Mot correct d√©cod√©

        for (let i = 0; i <= cleaned.length - 3; i += 3) {
          const triplet = cleaned.substring(i, i + 3);
          triplets.push(triplet);

          const decodedChar = geneticCode[triplet];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            // Forcer les minuscules accentu√©es √† s'afficher en majuscules
            if (decodedChar === "√©") displayChar = "√â";
            if (decodedChar === "√®") displayChar = "√à";
            if (decodedChar === "√™") displayChar = "√ä";
            if (decodedChar === "√´") displayChar = "√ã";
            if (decodedChar === "√Ø") displayChar = "√è";

            decodedChars.push({ char: displayChar, isMarker: false });
            // Construire le mot correct
            correctWord += displayChar;
          } else {
            decodedChars.push({ char: "?", isMarker: false });
          }
        }

        // Stocker le mot correct pour la validation
        window.modalCorrectWord = correctWord;

        // Cr√©er le contenu de la modale
        let html = '<div style="margin-bottom: 30px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">S√©quence ADN : ' +
          cleaned +
          "</h3>";

        // Premi√®re ligne : inputs pour les lettres
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; justify-content: center; align-items: center;">';
        let existingWordIndex = 0; // Index pour parcourir le mot existant
        decodedChars.forEach((item, index) => {
          // Pr√©remplir avec la lettre existante si disponible
          const existingLetter =
            existingWord && existingWordIndex < existingWord.length
              ? existingWord[existingWordIndex].toUpperCase()
              : "";
          existingWordIndex++;

          html += `<input type="text"
                          id="letter-${index}"
                          maxlength="1"
                          value="${existingLetter}"
                          style="width: 40px; height: 40px; text-align: center; font-size: 1.5rem; border: 2px solid #667eea; border-radius: 6px; font-weight: bold; text-transform: uppercase;"
                          placeholder="?"
                          oninput="this.value = this.value.toUpperCase()">`;
        });
        html += "</div>";

        // Bouton de validation
        html += '<div style="text-align: center; margin: 20px 0;">';
        html +=
          '<button id="validateDecode" style="background: #51cf66; color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: bold;">Valider</button>';
        html += "</div>";

        // Deuxi√®me ligne : les triplets
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 30px; justify-content: center; font-family: monospace;">';
        triplets.forEach((triplet, index) => {
          const isStop = ["TAA", "TAG", "TGA"].includes(triplet);
          let bgColor = "#e0e0e0";
          if (isStop) bgColor = "#ffb3d9";
          html += `<div style="width: 40px; height: 30px; text-align: center; padding-top: 5px; background: ${bgColor}; border-radius: 4px; font-size: 0.9rem;">${triplet}</div>`;
        });
        html += "</div>";

        // Troisi√®me ligne : code g√©n√©tique (tableau)
        html +=
          '<div style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 20px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Code G√©n√©tique</h3>';
        html += '<div style="overflow-x: auto;">';
        html +=
          '<table style="width: 100%; border-collapse: collapse; margin: 0 auto;">';
        html += "<thead><tr>";
        for (let i = 0; i < 4; i++) {
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); padding: 10px; text-align: center;">Codon</th>';
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); padding: 10px; text-align: center;">Symbole</th>';
        }
        html += "</tr></thead><tbody>";

        // Remplir le tableau avec le code g√©n√©tique (m√™me logique que la page principale)
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));
        const numColumns = 4;
        const entriesPerColumn = Math.ceil(entries.length / numColumns);

        // Cr√©er les lignes
        const tableRows = [];
        for (let i = 0; i < entriesPerColumn; i++) {
          const rowData = [];
          for (let j = 0; j < numColumns * 2; j++) {
            rowData.push(null);
          }
          tableRows.push(rowData);
        }

        // Remplir colonne par colonne (verticalement)
        entries.forEach(([codon, symbol], index) => {
          const columnIndex = Math.floor(index / entriesPerColumn);
          const rowIndex = index % entriesPerColumn;

          if (columnIndex >= numColumns) return;

          const codonCellIndex = columnIndex * 2;
          const symbolCellIndex = codonCellIndex + 1;

          tableRows[rowIndex][codonCellIndex] = codon;
          tableRows[rowIndex][symbolCellIndex] = symbol;
        });

        // G√©n√©rer le HTML des lignes
        tableRows.forEach((row) => {
          html += "<tr>";
          for (let i = 0; i < row.length; i += 2) {
            const codon = row[i];
            const symbol = row[i + 1];
            if (codon && symbol) {
              const isStop = ["TAA", "TAG", "TGA"].includes(codon);
              const bgColor = isStop ? "#ffb3d9" : "";
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor}; font-family: monospace;">${codon}</td>`;
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor};">${symbol}</td>`;
            } else {
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
            }
          }
          html += "</tr>";
        });

        html += "</tbody></table>";
        html += "</div>";
        html += "</div>";

        modalContent.innerHTML = html;
        modal.style.display = "block";

        // Stocker les donn√©es pour la fonction de validation
        window.modalDecodedChars = decodedChars;

        // Fonction pour valider et remplacer la s√©quence ADN par le mot saisi
        window.validateDecode = function () {
          let userWord = "";

          // R√©cup√©rer toutes les lettres saisies
          if (window.modalDecodedChars) {
            window.modalDecodedChars.forEach((item, index) => {
              const input = document.getElementById(`letter-${index}`);
              if (input) {
                const letter = input.value.trim().toUpperCase();
                userWord += letter || "?";
              }
            });
          }

          // Remplacer le span original par le mot saisi
          if (window.modalOriginalSpan && userWord) {
            // Cr√©er un nouveau span avec le mot saisi
            const newSpan = document.createElement("span");
            newSpan.textContent = userWord;
            newSpan.className =
              window.modalOriginalSpan.className + " decode-filled";
            // Stocker la s√©quence ADN originale pour pouvoir la modifier √† nouveau
            newSpan.setAttribute("data-dna", window.modalDNASequence);

            // Comparer le mot saisi avec le mot correct
            const correctWord = window.modalCorrectWord || "";

            // Normaliser les deux cha√Ænes pour la comparaison
            // Convertir en majuscules et normaliser les caract√®res accentu√©s
            function normalizeForComparison(str) {
              return str.toUpperCase().normalize("NFC"); // Normaliser en forme compos√©e canonique
            }

            const normalizedUser = normalizeForComparison(userWord);
            const normalizedCorrect = normalizeForComparison(correctWord);

            // Comparaison avec debug (peut √™tre retir√© apr√®s)
            console.log(
              "User word:",
              userWord,
              "-> Normalized:",
              normalizedUser
            );
            console.log(
              "Correct word:",
              correctWord,
              "-> Normalized:",
              normalizedCorrect
            );
            console.log("Match:", normalizedUser === normalizedCorrect);

            // Comparaison directe en majuscules (fallback)
            const directComparison =
              userWord.toUpperCase() === correctWord.toUpperCase();
            console.log("Direct comparison:", directComparison);

            // Utiliser les deux m√©thodes de comparaison
            const isCorrect =
              normalizedUser === normalizedCorrect || directComparison;

            console.log("Final isCorrect:", isCorrect);

            // Appliquer la couleur selon la justesse
            if (isCorrect) {
              // Vert pastel si correct
              console.log("Applying green color");
              newSpan.style.setProperty("background", "#b3ffb3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#b3ffb3",
                "important"
              );
            } else {
              // Rouge pastel si incorrect
              console.log("Applying red color");
              newSpan.style.setProperty("background", "#ffb3b3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#ffb3b3",
                "important"
              );
            }

            console.log("Final background color:", newSpan.style.background);
            console.log(
              "Final computed style:",
              window.getComputedStyle(newSpan).backgroundColor
            );

            newSpan.style.cursor = "pointer";
            newSpan.style.userSelect = "none";
            newSpan.style.webkitUserSelect = "none";
            newSpan.style.mozUserSelect = "none";
            newSpan.style.msUserSelect = "none";
            newSpan.title = "Double-cliquez pour modifier";

            // Ajouter l'√©v√©nement de double-clic/double-tap pour permettre de modifier √† nouveau
            newSpan.addEventListener("dblclick", function (e) {
              e.preventDefault();
              const dnaSequence = this.getAttribute("data-dna");
              openDecodeModal(dnaSequence, this);
            });

            // Emp√™cher la s√©lection de texte sur mobile
            newSpan.addEventListener(
              "touchstart",
              function (e) {
                const currentTime = new Date().getTime();
                const timeSinceLastTap =
                  currentTime - window.lastDecodeTap.time;
                if (
                  timeSinceLastTap < 300 &&
                  window.lastDecodeTap.target === this
                ) {
                  e.preventDefault();
                }
              },
              { passive: false }
            );

            // Double-tap pour mobile/tactile
            newSpan.addEventListener(
              "touchend",
              function (e) {
                const currentTime = new Date().getTime();
                const timeSinceLastTap =
                  currentTime - window.lastDecodeTap.time;

                // V√©rifier si c'est un double-tap sur le m√™me √©l√©ment
                if (
                  timeSinceLastTap < 300 &&
                  timeSinceLastTap > 0 &&
                  window.lastDecodeTap.target === this
                ) {
                  // Double tap d√©tect√©
                  e.preventDefault();
                  e.stopPropagation();

                  // Annuler toute s√©lection de texte
                  if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                  }

                  const dnaSequence = this.getAttribute("data-dna");
                  openDecodeModal(dnaSequence, this);

                  // R√©initialiser pour √©viter les triple-taps
                  window.lastDecodeTap.time = 0;
                  window.lastDecodeTap.target = null;
                } else {
                  // Premier tap
                  window.lastDecodeTap.time = currentTime;
                  window.lastDecodeTap.target = this;
                }
              },
              { passive: false }
            );

            // Remplacer l'ancien span par le nouveau
            window.modalOriginalSpan.parentNode.replaceChild(
              newSpan,
              window.modalOriginalSpan
            );
          }

          // Fermer la modale
          const modal = document.getElementById("decodeModal");
          if (modal) {
            modal.style.display = "none";
          }
        };

        // Ajouter l'√©v√©nement sur le bouton de validation
        setTimeout(() => {
          const validateBtn = document.getElementById("validateDecode");
          if (validateBtn) {
            validateBtn.addEventListener("click", window.validateDecode);
          }

          // Fonction pour trouver l'index de la prochaine case
          function findNextInputIndex(currentIndex, direction) {
            const maxIndex = window.modalDecodedChars.length - 1;
            let nextIndex;
            if (direction === 1) {
              // Vers la droite
              nextIndex = (currentIndex + 1) % (maxIndex + 1);
            } else {
              // Vers la gauche
              nextIndex = (currentIndex - 1 + maxIndex + 1) % (maxIndex + 1);
            }
            return nextIndex;
          }

          // Ajouter la gestion du clavier sur tous les inputs
          window.modalDecodedChars.forEach((item, index) => {
            const input = document.getElementById(`letter-${index}`);
            if (input) {
              input.addEventListener("keydown", function (e) {
                if (e.key === "Enter") {
                  e.preventDefault();
                  // Passer √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowRight") {
                  e.preventDefault();
                  // Aller √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowLeft") {
                  e.preventDefault();
                  // Aller √† la case pr√©c√©dente
                  const prevIndex = findNextInputIndex(index, -1);
                  const prevInput = document.getElementById(
                    `letter-${prevIndex}`
                  );
                  if (prevInput) {
                    prevInput.focus();
                    prevInput.select();
                  }
                }
              });

              // Passer automatiquement √† la case suivante quand une lettre est entr√©e
              input.addEventListener("input", function (e) {
                const value = this.value.trim().toUpperCase();
                // Si une lettre a √©t√© entr√©e (pas vide, pas juste supprim√©e)
                if (
                  value.length === 1 &&
                  /[A-Z√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û√ü]/.test(value)
                ) {
                  // Passer √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    // Petit d√©lai pour s'assurer que la valeur est bien mise √† jour
                    setTimeout(() => {
                      nextInput.focus();
                      nextInput.select();
                    }, 10);
                  }
                }
              });
            }
          });
        }, 10);
      }

      // Fermer la modale
      document
        .getElementById("closeModal")
        .addEventListener("click", function () {
          document.getElementById("decodeModal").style.display = "none";
        });

      // Fermer la modale en cliquant en dehors
      document
        .getElementById("decodeModal")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            this.style.display = "none";
          }
        });

      // Fonction pour normaliser le texte (tous les types d'apostrophes -> apostrophe standard)
      function normalizeText(text) {
        if (!text) return text;
        // Normaliser tous les types d'apostrophes vers l'apostrophe standard
        // Utiliser les codes Unicode pour capturer tous les types possibles
        // U+0027: ' (apostrophe droite)
        // U+2018: ' (guillemet simple ouvrant)
        // U+2019: ' (apostrophe typographique)
        // U+201A: ‚Äö (guillemet-virgule inf√©rieur)
        // U+201B: ‚Äõ (guillemet simple ouvrant renvers√©)
        // U+2032: ‚Ä≤ (prime)
        // U+2035: ‚Äµ (prime renvers√©e)
        // U+02BC:  º (lettre modificative apostrophe)
        // U+02BB:  ª (lettre modificative guillemet simple)
        // U+0060: ` (accent grave)
        // U+00B4: ¬¥ (accent aigu)
        // Utiliser une approche plus permissive pour capturer tous les caract√®res similaires
        let normalized = text;
        // Normaliser tous les types d'espaces vers l'espace standard (U+0020)
        // U+0020: espace standard
        // U+00A0: espace ins√©cable
        // U+2000-U+200B: diff√©rents types d'espaces (en quadratin, cadratin, etc.)
        // U+202F: espace ins√©cable √©troit
        // U+205F: espace math√©matique moyen
        // U+3000: espace id√©ographique
        normalized = normalized.replace(
          /[\u00A0\u2000-\u200B\u202F\u205F\u3000]/g,
          " "
        );
        // Remplacer tous les types d'apostrophes par l'apostrophe standard
        normalized = normalized.replace(/[''‚Äö‚Äõ‚Ä≤‚Äµ º ª`¬¥]/g, "'");
        // Remplacer aussi par code Unicode pour √™tre s√ªr
        normalized = normalized.replace(
          /[\u0027\u2018\u2019\u201A\u201B\u2032\u2035\u02BC\u02BB\u0060\u00B4]/g,
          "'"
        );
        // Guillemets typographiques
        normalized = normalized.replace(/[""]/g, '"');
        normalized = normalized.replace(/[""]/g, '"');
        return normalized;
      }

      // Fonction pour obtenir la classe CSS selon le nombre de nucl√©otides
      function getNucleotideClass(nucleotideCount) {
        if (nucleotideCount <= 12) return "word-short";
        if (nucleotideCount <= 18) return "word-medium";
        if (nucleotideCount <= 27) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer la s√©quence ADN selon la longueur des mots
      function colorizeDNA(dna, wordPositions, dnaToText = null) {
        currentWordPositions = wordPositions.filter((w) => w.type === "word");
        let wordIndex = 0;
        let html = `<span>${dna.substring(0, 3)}</span>`; // ATG au d√©but
        let lastEnd = 3; // Position apr√®s ATG

        for (let word of wordPositions) {
          // V√©rifier s'il y a des codons stop entre lastEnd et word.start
          for (let i = lastEnd; i < word.start; i += 3) {
            const codon = dna.substring(i, i + 3);
            if (["TAA", "TAG", "TGA"].includes(codon)) {
              html += `<span class="word-stop" title="Point">${codon}</span>`;
              lastEnd = i + 3;
            }
          }

          if (word.type === "space") {
            // Espace (TTT = 3 nucl√©otides)
            html += `<span class="word-space">${dna.substring(
              word.start,
              word.end
            )}</span>`;
            lastEnd = word.end;
          } else {
            // Mot
            const nucleotideCount = word.end - word.start;
            let className = getNucleotideClass(nucleotideCount);
            const wordDNA = dna.substring(word.start, word.end);
            const tooltip =
              dnaToText && dnaToText[wordDNA]
                ? ` title="${dnaToText[wordDNA]}"`
                : "";

            // Ajouter la classe "word-trou" si le mot est s√©lectionn√©
            if (trouModeActive && selectedWordIndices.has(wordIndex)) {
              className += " word-trou";
            }

            // Ajouter l'√©v√©nement de double-clic si le mode est actif
            const dataIndex = trouModeActive
              ? ` data-word-index="${wordIndex}" ondblclick="toggleWordTrou(${wordIndex})" style="cursor: pointer;"`
              : "";

            html += `<span class="${className}"${tooltip}${dataIndex}>${wordDNA}</span>`;
            lastEnd = word.end;
            wordIndex++;
          }
        }

        // V√©rifier s'il y a des codons stop apr√®s le dernier mot
        for (let i = lastEnd; i <= dna.length - 3; i += 3) {
          const codon = dna.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            lastEnd = i + 3;
          } else {
            break; // Arr√™ter si on rencontre un autre codon
          }
        }

        // Ajouter le reste de la s√©quence (s'il y en a)
        if (lastEnd < dna.length) {
          html += `<span>${dna.substring(lastEnd)}</span>`;
        }

        return html;
      }

      // Fonction pour basculer un mot en mode "√† trou"
      function toggleWordTrou(wordIndex) {
        if (!trouModeActive) return;

        if (selectedWordIndices.has(wordIndex)) {
          selectedWordIndices.delete(wordIndex);
        } else {
          selectedWordIndices.add(wordIndex);
        }

        // R√©encoder pour mettre √† jour l'affichage
        encodeText();
      }

      // Fonction pour afficher/cacher le label au-dessus de dnaOutput
      function updateDnaOutputLabel() {
        const output = document.getElementById("dnaOutput");
        const label = document.getElementById("dnaOutputLabel");
        if (!output || !label) return;

        const hasSequence =
          output.getAttribute("data-dna-sequence") &&
          output.getAttribute("data-dna-sequence").length > 0;
        const hasContent =
          output.innerHTML &&
          output.innerHTML.trim() !== "" &&
          !output.innerHTML.includes("Aucune s√©quence √† afficher");

        if (hasSequence || hasContent) {
          label.style.display = "block";
        } else {
          label.style.display = "none";
        }
      }

      function encodeText() {
        const input = document.getElementById("textInput").value;
        const normalized = normalizeText(input);
        const output = document.getElementById("dnaOutput");
        let dna = "ATG";
        const wordPositions = [];
        const dnaToText = {}; // Correspondance ADN -> texte
        let currentWordStart = 3; // Apr√®s ATG
        let currentWordText = ""; // Texte du mot en cours
        let inWord = false;
        let isStartOfSentence = true; // Pour d√©tecter le d√©but de phrase

        for (let char of normalized) {
          let codonLength = 0;
          // G√©rer les caract√®res sp√©ciaux en premier (ponctuation)
          if (char === ".") {
            // Finaliser le mot actuel AVANT d'ajouter le point
            if (inWord) {
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            // Maintenant ajouter le point (qui ne fait pas partie du mot)
            dna += "TAA";
            // Ne pas mettre codonLength pour √©viter que le point initialise un nouveau mot
            isStartOfSentence = true; // Apr√®s un point, on est au d√©but d'une phrase
            continue; // Passer au caract√®re suivant sans traiter le point comme un codon de mot
          }
          // G√©rer l'apostrophe (tous les types normalis√©s vers ')
          // V√©rifier aussi directement les codes Unicode au cas o√π la normalisation n'a pas fonctionn√©
          else if (
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char.charCodeAt(0) === 0x0027 ||
            char.charCodeAt(0) === 0x2019 ||
            char.charCodeAt(0) === 0x2018
          ) {
            dna += "TTC";
            codonLength = 3;
            if (inWord) {
              currentWordText += "'";
            }
          }
          // G√©rer les espaces (tous les types normalis√©s vers espace standard)
          // V√©rifier aussi directement les codes Unicode au cas o√π la normalisation n'a pas fonctionn√©
          else if (
            char === " " ||
            char.charCodeAt(0) === 0x0020 ||
            char.charCodeAt(0) === 0x00a0 ||
            (char.charCodeAt(0) >= 0x2000 && char.charCodeAt(0) <= 0x200b) ||
            char.charCodeAt(0) === 0x202f ||
            char.charCodeAt(0) === 0x205f ||
            char.charCodeAt(0) === 0x3000
          ) {
            if (inWord) {
              // Finir le mot pr√©c√©dent
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            const spaceStart = dna.length;
            dna += "TTT";
            wordPositions.push({
              type: "space",
              start: spaceStart,
              end: dna.length,
            });
            currentWordStart = dna.length;
            continue;
          }
          // G√©rer les caract√®res accentu√©s (toujours en majuscule)
          else if (char === "√©" || char === "√â") {
            dna += "AGG"; // AGG (√â)
            codonLength = 3;
            if (inWord) currentWordText += "√â";
            isStartOfSentence = false;
          } else if (char === "√®" || char === "√à") {
            dna += "AGT"; // AGT (√à)
            codonLength = 3;
            if (inWord) currentWordText += "√à";
            isStartOfSentence = false;
          } else if (char === "√™" || char === "√ä") {
            dna += "ATA"; // ATA (√ä)
            codonLength = 3;
            if (inWord) currentWordText += "√ä";
            isStartOfSentence = false;
          } else if (char === "√´" || char === "√ã") {
            dna += "ATC"; // ATC (√ã)
            codonLength = 3;
            if (inWord) currentWordText += "√ã";
            isStartOfSentence = false;
          } else if (char === "√Ø" || char === "√è") {
            dna += "CCG"; // CCG (√è)
            codonLength = 3;
            if (inWord) currentWordText += "√è";
            isStartOfSentence = false;
          }
          // Pour les autres caract√®res
          else {
            let upperChar = char.toUpperCase();

            if (reverseCode[upperChar]) {
              dna += reverseCode[upperChar][0];
              codonLength = 3;
              if (inWord) currentWordText += upperChar;
              isStartOfSentence = false;
            }
            // Les caract√®res non codables sont simplement ignor√©s
          }

          if (codonLength > 0) {
            if (!inWord) {
              currentWordStart = dna.length - codonLength;
              inWord = true;
              // Initialiser le texte du mot avec le premier caract√®re
              if (char === "√©" || char === "√â") {
                currentWordText = "√â";
              } else if (char === "√®" || char === "√à") {
                currentWordText = "√à";
              } else if (char === "√™" || char === "√ä") {
                currentWordText = "√ä";
              } else if (char === "√´" || char === "√ã") {
                currentWordText = "√ã";
              } else if (char === "√Ø" || char === "√è") {
                currentWordText = "√è";
              } else if (
                char === "'" ||
                char === "'" ||
                char === "'" ||
                char === "'"
              ) {
                currentWordText = "'";
              } else if (char !== ".") {
                currentWordText = char.toUpperCase();
              } else {
                currentWordText = "";
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord) {
          const wordDNA = dna.substring(currentWordStart, dna.length);
          if (currentWordText) {
            dnaToText[wordDNA] = currentWordText;
          }
          wordPositions.push({
            type: "word",
            start: currentWordStart,
            end: dna.length,
          });
        }

        // Ajouter les positions des mots "√† trou" √† la fin de la s√©quence si le mode est actif
        const copyBtn = document.getElementById("copyBtn");
        const exportBtn = document.getElementById("exportBtn");

        // Stocker la s√©quence de base (sans marqueurs "√† trou")
        output.setAttribute("data-dna-base", dna);

        // Toujours afficher la s√©quence ADN coloris√©e
        const coloredDNA = colorizeDNA(dna, wordPositions, dnaToText);

        if (selectedWordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(selectedWordIndices);
          const fullSequence = dna + trouPositions;
          // Stocker la s√©quence compl√®te avec les positions dans un attribut data
          output.setAttribute("data-dna-sequence", fullSequence);
          output.setAttribute("data-trou-positions", trouPositions);
          // Afficher la s√©quence ADN coloris√©e (le texte reste visible)
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune s√©quence √† afficher.</span>';
          // Afficher les boutons
          copyBtn.style.display = "inline-block";
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
        } else if (trouModeActive) {
          // Mode "√† trou" actif mais aucun mot s√©lectionn√© - afficher quand m√™me la s√©quence
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune s√©quence √† afficher. Double-cliquez sur les mots pour les s√©lectionner.</span>';
          // Afficher le bouton d'export
          copyBtn.style.display = "none";
          const exportBtn = document.getElementById("exportBtn");
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
        } else {
          // Mode "√† trou" d√©sactiv√©
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML = coloredDNA || "";
          // Afficher le bouton d'export m√™me sans "√† trou"
          copyBtn.style.display = "none";
          const exportBtn = document.getElementById("exportBtn");
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
        }
      }

      // Fonction pour copier la s√©quence ADN avec les marqueurs "√† trou"
      function copyDNAWithTrous() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (fullSequence) {
          // Copier la s√©quence compl√®te (d√©j√† avec le marqueur et les positions)
          navigator.clipboard
            .writeText(fullSequence)
            .then(() => {
              const btn = document.getElementById("copyBtn");
              const originalText = btn.textContent;
              btn.textContent = "‚úì Copi√© !";
              btn.style.background = "#51cf66";
              setTimeout(() => {
                btn.textContent = originalText;
              }, 2000);
            })
            .catch((err) => {
              console.error("Erreur lors de la copie:", err);
              alert(
                "Erreur lors de la copie. Veuillez s√©lectionner manuellement la s√©quence."
              );
            });
        }
      }

      // Fonction pour ouvrir la modale d'import
      function openImportModal() {
        const modal = document.getElementById("importModal");
        if (modal) {
          modal.style.display = "block";
        }
      }

      // Fonction pour fermer la modale d'import
      function closeImportModal() {
        const modal = document.getElementById("importModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour ouvrir le s√©lecteur de fichier selon le format choisi
      async function openImportFormat(format) {
        closeImportModal();

        // Essayer d'utiliser l'API File System Access pour ouvrir le dossier de t√©l√©chargements
        if ("showOpenFilePicker" in window) {
          try {
            const acceptTypes =
              format === "edi"
                ? { "text/plain": [".edi"] }
                : { "text/plain": [".fasta", ".fa", ".fas"] };

            const [fileHandle] = await window.showOpenFilePicker({
              types: [{ accept: acceptTypes }],
              multiple: false,
              startIn: "downloads", // Sugg√®re le dossier de t√©l√©chargements
            });

            const file = await fileHandle.getFile();
            const event = { target: { files: [file] } };

            if (format === "edi") {
              importEDIFile(event);
            } else if (format === "fasta") {
              importFASTAFile(event);
            }
            return;
          } catch (error) {
            // Si l'utilisateur annule ou si l'API √©choue, utiliser l'input file classique
            if (error.name !== "AbortError") {
              console.log(
                "API File System Access non disponible, utilisation de l'input file classique"
              );
            }
          }
        }

        // Fallback : utiliser l'input file classique
        if (format === "edi") {
          document.getElementById("ediFileInput").click();
        } else if (format === "fasta") {
          document.getElementById("fastaFileInput").click();
        }
      }

      // Fonction pour ouvrir la modale d'export
      function openExportModal() {
        const modal = document.getElementById("exportModal");
        if (modal) {
          modal.style.display = "block";
        }
      }

      // Fonction pour fermer la modale d'export
      function closeExportModal() {
        const modal = document.getElementById("exportModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour exporter selon le format choisi
      function openExportFormat(format) {
        closeExportModal();
        // Ouvrir la modale de sauvegarde avec le format choisi
        openSaveFileModal(format);
      }

      // Variables globales pour la sauvegarde
      let currentExportFormat = "fasta";
      let selectedDirectoryHandle = null;

      // Fonction pour ouvrir la modale de sauvegarde
      function openSaveFileModal(format = "fasta") {
        currentExportFormat = format;
        const modal = document.getElementById("saveFileModal");
        const fileNameInput = document.getElementById("fileNameInput");
        const fileExtensionInfo = document.getElementById("fileExtensionInfo");

        if (!modal || !fileNameInput || !fileExtensionInfo) return;

        // D√©finir le nom de fichier par d√©faut selon le format
        const defaultName =
          format === "edi" ? "sequence_encod√©e" : "sequence_encod√©e";
        fileNameInput.value = defaultName;
        fileExtensionInfo.textContent = `Extension : .${format}`;

        // R√©initialiser le r√©pertoire s√©lectionn√©
        selectedDirectoryHandle = null;
        const directoryInfo = document.getElementById("directoryInfo");
        if (directoryInfo) {
          if ("showDirectoryPicker" in window) {
            directoryInfo.textContent =
              "Le fichier sera t√©l√©charg√© dans le r√©pertoire par d√©faut de votre navigateur. Cliquez sur 'Choisir le r√©pertoire' pour s√©lectionner un emplacement.";
          } else {
            directoryInfo.textContent =
              "Le fichier sera t√©l√©charg√© dans le r√©pertoire par d√©faut de votre navigateur. Le choix de r√©pertoire n'est pas disponible dans votre navigateur.";
          }
        }

        // D√©sactiver le bouton de choix de r√©pertoire si l'API n'est pas disponible
        const chooseDirectoryBtn =
          document.getElementById("chooseDirectoryBtn");
        if (chooseDirectoryBtn) {
          if ("showDirectoryPicker" in window) {
            chooseDirectoryBtn.disabled = false;
            chooseDirectoryBtn.style.opacity = "1";
            chooseDirectoryBtn.style.cursor = "pointer";
          } else {
            chooseDirectoryBtn.disabled = true;
            chooseDirectoryBtn.style.opacity = "0.5";
            chooseDirectoryBtn.style.cursor = "not-allowed";
          }
        }

        modal.style.display = "block";
        // Focus sur le champ de nom de fichier
        setTimeout(() => {
          fileNameInput.focus();
          fileNameInput.select();
        }, 100);
      }

      // Fonction pour fermer la modale de sauvegarde
      function closeSaveFileModal() {
        const modal = document.getElementById("saveFileModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour choisir le r√©pertoire (API File System Access)
      async function chooseDirectory() {
        try {
          // V√©rifier si l'API est disponible (Chrome/Edge)
          if ("showDirectoryPicker" in window) {
            const directoryHandle = await window.showDirectoryPicker();
            selectedDirectoryHandle = directoryHandle;
            const directoryInfo = document.getElementById("directoryInfo");
            if (directoryInfo) {
              directoryInfo.textContent = `R√©pertoire s√©lectionn√© : ${directoryHandle.name}`;
            }
          } else {
            alert(
              "Le choix de r√©pertoire n'est pas disponible dans votre navigateur. Le fichier sera t√©l√©charg√© dans le r√©pertoire par d√©faut."
            );
          }
        } catch (error) {
          // L'utilisateur a annul√© la s√©lection
          if (error.name !== "AbortError") {
            console.error("Erreur lors de la s√©lection du r√©pertoire:", error);
          }
        }
      }

      // Fonction pour confirmer la sauvegarde
      async function confirmSaveFile() {
        const fileNameInput = document.getElementById("fileNameInput");
        if (!fileNameInput) return;

        let fileName = fileNameInput.value.trim();
        if (!fileName) {
          alert("Veuillez entrer un nom de fichier.");
          return;
        }

        // Nettoyer le nom de fichier (enlever les caract√®res invalides)
        fileName = fileName.replace(/[<>:"/\\|?*]/g, "_");

        // Ajouter l'extension si elle n'est pas pr√©sente
        if (!fileName.endsWith("." + currentExportFormat)) {
          fileName += "." + currentExportFormat;
        }

        // Fermer la modale
        closeSaveFileModal();

        // Exporter le fichier
        if (currentExportFormat === "edi") {
          await exportEDIFile(fileName);
        } else if (currentExportFormat === "fasta") {
          await exportFASTAFile(fileName);
        }
      }

      // Fonction pour exporter la s√©quence ADN en format .edi
      // Fonction utilitaire pour t√©l√©charger un fichier (compatible mobile et desktop)
      function downloadFile(blob, fileName) {
        const isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.innerWidth <= 768;
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", fileName);

        if (isMobile) {
          // Pour mobile : utiliser une approche plus compatible
          link.style.position = "fixed";
          link.style.top = "-1000px";
          link.style.left = "-1000px";
          link.style.opacity = "0";
        } else {
          // Pour desktop : m√©thode standard
          link.style.display = "none";
          link.style.visibility = "hidden";
        }

        document.body.appendChild(link);

        // D√©clencher le t√©l√©chargement avec plusieurs m√©thodes pour compatibilit√© maximale
        try {
          link.click();
        } catch (e) {
          // Si click() ne fonctionne pas, essayer avec un √©v√©nement de souris
          const clickEvent = new MouseEvent("click", {
            view: window,
            bubbles: true,
            cancelable: true,
          });
          link.dispatchEvent(clickEvent);
        }

        // Nettoyer apr√®s un d√©lai (plus long pour mobile)
        setTimeout(
          () => {
            if (document.body.contains(link)) {
              document.body.removeChild(link);
            }
            URL.revokeObjectURL(url);
          },
          isMobile ? 1000 : 100
        );
      }

      async function exportEDIFile(fileName = "sequence_encod√©e.edi") {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune s√©quence √† exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format .edi : format simple avec la s√©quence ADN (peut √™tre r√©import√©)
        // On exporte juste la s√©quence ADN, le format .edi sera reconnu par l'import
        const ediFile = fullSequence;

        // T√©l√©charger directement (compatible mobile/tablette, pas de message d'avertissement)
        const blob = new Blob([ediFile], { type: "text/plain;charset=utf-8;" });
        downloadFile(blob, fileName);
      }

      // Fonction pour exporter la s√©quence ADN en format .fasta
      async function exportFASTAFile(fileName = "sequence_encod√©e.fasta") {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune s√©quence √† exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format FASTA : en-t√™te suivi de la s√©quence (60 caract√®res par ligne)
        const fastaContent = `>Sequence_ADN_encodee\n`;
        const sequenceLines = fullSequence.match(/.{1,60}/g) || [fullSequence];
        const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

        // T√©l√©charger directement (compatible mobile/tablette, pas de message d'avertissement)
        const blob = new Blob([fastaFile], {
          type: "text/plain;charset=utf-8;",
        });
        downloadFile(blob, fileName);
      }

      const tbody = document.getElementById("codeTable");
      const entries = Object.entries(geneticCode)
        .filter(([k, v]) => v !== "START")
        .sort(([a], [b]) => a.localeCompare(b));

      // Organiser en 4 colonnes, remplir verticalement (colonne par colonne)
      const numColumns = 4; // 4 colonnes de paires Codon/Symbole
      const entriesPerColumn = Math.ceil(entries.length / numColumns);

      // Cr√©er toutes les lignes n√©cessaires avec toutes les cellules vides
      const rows = [];
      for (let i = 0; i < entriesPerColumn; i++) {
        const row = document.createElement("tr");
        // Cr√©er 8 cellules vides (4 paires Codon/Symbole)
        for (let j = 0; j < numColumns * 2; j++) {
          const cell = document.createElement("td");
          row.appendChild(cell);
        }
        rows.push(row);
        tbody.appendChild(row);
      }

      // Remplir colonne par colonne (verticalement)
      // Colonne 0 : entr√©es 0, 1, 2, 3, ...
      // Colonne 1 : entr√©es entriesPerColumn, entriesPerColumn+1, ...
      // Colonne 2 : entr√©es 2*entriesPerColumn, 2*entriesPerColumn+1, ...
      // Colonne 3 : entr√©es 3*entriesPerColumn, 3*entriesPerColumn+1, ...
      entries.forEach(([codon, symbol], index) => {
        // Calculer la colonne et la ligne pour un remplissage vertical
        const columnIndex = Math.floor(index / entriesPerColumn);
        const rowIndex = index % entriesPerColumn;

        // S'assurer qu'on ne d√©passe pas le nombre de colonnes
        if (columnIndex >= numColumns) return;

        const row = rows[rowIndex];

        // Trouver la position dans la ligne (chaque colonne = 2 cellules : Codon + Symbole)
        const codonCellIndex = columnIndex * 2;
        const symbolCellIndex = codonCellIndex + 1;

        // Remplir les cellules
        row.cells[codonCellIndex].textContent = codon;
        row.cells[symbolCellIndex].textContent = symbol;

        // Colorer les codons stop en rose pastel
        if (["TAA", "TAG", "TGA"].includes(codon)) {
          row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
          row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
        }
      });

      // Coloriser le textarea de d√©codage en temps r√©el
      const dnaInput = document.getElementById("dnaInput");
      dnaInput.addEventListener("input", function () {
        setTimeout(colorizeDNAInput, 10);
      });
      dnaInput.addEventListener("paste", function () {
        setTimeout(colorizeDNAInput, 10); // Attendre que le collage soit termin√©
      });

      // Gestion du menu contextuel pour les modifications de s√©quence
      const contextMenu = document.getElementById("contextMenu");
      let selectedRange = null;
      let selectedText = "";
      let selectedStart = 0;
      let selectedEnd = 0;

      // Fonction pour obtenir la s√©lection dans un √©l√©ment contenteditable
      function getSelectionInEditable(element) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return null;

        const range = selection.getRangeAt(0);

        // V√©rifier si la s√©lection est dans l'√©l√©ment
        let container = range.commonAncestorContainer;
        while (container && container !== element) {
          if (
            container.nodeType === Node.ELEMENT_NODE &&
            container.isContentEditable
          ) {
            // C'est un √©l√©ment contenteditable parent, v√©rifier s'il contient notre √©l√©ment
            if (!container.contains(element)) {
              return null;
            }
          }
          container = container.parentNode;
        }

        if (
          !element.contains(range.commonAncestorContainer) &&
          !range.commonAncestorContainer.contains(element)
        ) {
          return null;
        }

        // Cr√©er une nouvelle plage pour √©viter les probl√®mes
        const newRange = range.cloneRange();
        newRange.setStart(range.startContainer, range.startOffset);
        newRange.setEnd(range.endContainer, range.endOffset);

        // Obtenir le texte brut de la s√©lection (sans HTML)
        const text = newRange.toString();
        if (!text || text.trim().length === 0) return null;

        // Obtenir les positions dans le texte complet (texte brut sans HTML)
        const elementText = element.innerText || element.textContent || "";
        const preRange = newRange.cloneRange();
        preRange.selectNodeContents(element);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;

        return {
          range: newRange,
          text: text,
          start: start,
          end: start + text.length,
        };
      }

      // Fonction pour obtenir le texte brut d'un √©l√©ment contenteditable
      function getPlainText(element) {
        return element.innerText || element.textContent || "";
      }

      // Fonction pour obtenir les positions dans le texte brut
      function getTextPositions(element, range) {
        const text = getPlainText(element);
        const preRange = range.cloneRange();
        preRange.selectNodeContents(element);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;
        const selectedText = range.toString();
        return {
          start: start,
          end: start + selectedText.length,
          text: selectedText,
        };
      }

      // Afficher le menu contextuel
      dnaInput.addEventListener("contextmenu", function (e) {
        e.preventDefault();

        const selection = getSelectionInEditable(dnaInput);
        if (!selection) {
          contextMenu.style.display = "none";
          return;
        }

        selectedRange = selection.range;
        selectedText = selection.text;
        selectedStart = selection.start;
        selectedEnd = selection.end;

        // Filtrer pour ne garder que les nucl√©otides valides dans la s√©lection
        const validNucleotides = selectedText
          .toUpperCase()
          .replace(/[^ATCG]/g, "");
        if (validNucleotides.length === 0) {
          contextMenu.style.display = "none";
          return;
        }

        // Positionner le menu
        contextMenu.style.display = "block";
        contextMenu.style.left = e.pageX + "px";
        contextMenu.style.top = e.pageY + "px";
      });

      // Fermer le menu si on clique ailleurs
      document.addEventListener("click", function (e) {
        if (!contextMenu.contains(e.target) && e.target !== dnaInput) {
          contextMenu.style.display = "none";
        }
      });

      // Fonction pour g√©n√©rer un nucl√©otide al√©atoire
      function getRandomNucleotide() {
        const nucleotides = ["A", "T", "C", "G"];
        return nucleotides[Math.floor(Math.random() * nucleotides.length)];
      }

      // Fonction pour convertir les positions du texte brut en positions du texte nettoy√© (seulement ATCG)
      function convertToCleanedPositions(fullText, startPos, endPos) {
        let cleanedStart = 0;
        let cleanedEnd = 0;

        // Compter les caract√®res ATCG jusqu'√† startPos
        for (let i = 0; i < startPos && i < fullText.length; i++) {
          const char = fullText[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            cleanedStart++;
          }
        }

        // Compter les caract√®res ATCG jusqu'√† endPos
        for (let i = 0; i < endPos && i < fullText.length; i++) {
          const char = fullText[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            cleanedEnd++;
          }
        }

        return { start: cleanedStart, end: cleanedEnd };
      }

      // Fonction pour marquer les nucl√©otides comme modifi√©s dans le texte
      function markModifiedNucleotides(fullText, startPos, endPos) {
        // Convertir les positions du texte brut en positions du texte nettoy√©
        const cleanedPos = convertToCleanedPositions(
          fullText,
          startPos,
          endPos
        );

        // Stocker les positions modifi√©es dans un attribut data (en positions nettoy√©es)
        const dnaInput = document.getElementById("dnaInput");
        let modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );

        // Ajouter la nouvelle plage modifi√©e
        modifiedRanges.push({ start: cleanedPos.start, end: cleanedPos.end });

        // Fusionner les plages qui se chevauchent
        modifiedRanges.sort((a, b) => a.start - b.start);
        const merged = [];
        for (let range of modifiedRanges) {
          if (
            merged.length === 0 ||
            merged[merged.length - 1].end < range.start
          ) {
            merged.push(range);
          } else {
            merged[merged.length - 1].end = Math.max(
              merged[merged.length - 1].end,
              range.end
            );
          }
        }

        dnaInput.setAttribute("data-modified-ranges", JSON.stringify(merged));
      }

      // G√©rer les actions du menu
      contextMenu.addEventListener("click", function (e) {
        const action = e.target.getAttribute("data-action");
        if (!action || !selectedRange) {
          contextMenu.style.display = "none";
          return;
        }

        const dnaInput = document.getElementById("dnaInput");
        const fullText = getPlainText(dnaInput);
        const validSelection = selectedText
          .toUpperCase()
          .replace(/[^ATCG]/g, "");

        if (validSelection.length === 0) {
          contextMenu.style.display = "none";
          return;
        }

        let newText = "";
        let modifiedStart = selectedStart;
        let modifiedEnd = selectedEnd;

        if (action === "substitution") {
          // Substitution : remplacer al√©atoirement les nucl√©otides s√©lectionn√©s
          let substituted = "";
          for (let i = 0; i < validSelection.length; i++) {
            substituted += getRandomNucleotide();
          }

          // Remplacer dans le texte complet
          newText =
            fullText.substring(0, selectedStart) +
            substituted +
            fullText.substring(selectedEnd);

          modifiedStart = selectedStart;
          modifiedEnd = selectedStart + substituted.length;
        } else if (action === "addition") {
          // Addition : demander √† l'utilisateur d'entrer de nouveaux nucl√©otides
          const newNucleotides = prompt(
            "Entrez les nouveaux nucl√©otides √† ajouter (A, T, C, G uniquement) :",
            ""
          );
          if (newNucleotides === null) {
            contextMenu.style.display = "none";
            return;
          }

          const validNewNucleotides = newNucleotides
            .toUpperCase()
            .replace(/[^ATCG]/g, "");
          if (validNewNucleotides.length === 0) {
            alert(
              "Aucun nucl√©otide valide entr√©. Seuls A, T, C et G sont autoris√©s."
            );
            contextMenu.style.display = "none";
            return;
          }

          // Ins√©rer √† droite de la s√©lection (apr√®s selectedEnd)
          newText =
            fullText.substring(0, selectedEnd) +
            validNewNucleotides +
            fullText.substring(selectedEnd);

          modifiedStart = selectedEnd;
          modifiedEnd = selectedEnd + validNewNucleotides.length;
        } else if (action === "suppression") {
          // Suppression : retirer la s√©quence s√©lectionn√©e
          newText =
            fullText.substring(0, selectedStart) +
            fullText.substring(selectedEnd);

          // Pas de nucl√©otides modifi√©s pour la suppression
          modifiedStart = -1;
          modifiedEnd = -1;
        }

        // Mettre √† jour le contenu
        dnaInput.textContent = newText;

        // Mettre √† jour l'attribut data-full-sequence
        dnaInput.setAttribute("data-full-sequence", newText);

        // Marquer les nucl√©otides modifi√©s (sauf pour suppression)
        if (action !== "suppression" && modifiedStart >= 0) {
          markModifiedNucleotides(newText, modifiedStart, modifiedEnd);
        }

        // Recoloriser (la fonction colorizeDNAInput appliquera automatiquement le style aux nucl√©otides modifi√©s)
        setTimeout(colorizeDNAInput, 10);

        contextMenu.style.display = "none";
        selectedRange = null;
      });

      // Fonction pour importer un fichier .edi
      function importEDIFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format .edi : extraire la s√©quence ADN compl√®te (y compris les marqueurs "√† trou" TGGTGG)
            // On extrait toutes les s√©quences de nucl√©otides (A, T, C, G) pour pr√©server TGGTGG et les positions
            const sequences = text.match(/[ATCG]+/gi);

            if (sequences && sequences.length > 0) {
              // Concat√©ner toutes les s√©quences trouv√©es pour pr√©server les marqueurs "√† trou"
              const dnaSequence = sequences.join("").toUpperCase();
              // Stocker la s√©quence compl√®te (avec marqueurs) pour le d√©codage
              dnaInput.setAttribute("data-full-sequence", dnaSequence);
              // Afficher seulement la partie visible avant le marqueur
              const markerIndex = dnaSequence.indexOf(TROU_MARKER);
              const visible =
                markerIndex !== -1
                  ? dnaSequence.substring(0, markerIndex)
                  : dnaSequence;
              dnaInput.textContent = visible;
              colorizeDNAInput();
              alert("Fichier .edi import√© avec succ√®s !");
            } else {
              alert("Aucune s√©quence ADN trouv√©e dans le fichier .edi");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .edi : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour importer un fichier .fasta
      function importFASTAFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format FASTA : les lignes commen√ßant par > sont des en-t√™tes, les autres sont des s√©quences
            const lines = text.split("\n");
            let sequences = [];

            for (let line of lines) {
              line = line.trim();
              // Ignorer les lignes d'en-t√™te (commencent par >)
              if (line && !line.startsWith(">")) {
                // Extraire uniquement les caract√®res A, T, C, G (ignorer les espaces, retours √† la ligne, etc.)
                const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
                if (sequence.length > 0) {
                  sequences.push(sequence);
                }
              }
            }

            if (sequences.length > 0) {
              // Concat√©ner toutes les s√©quences trouv√©es
              const dnaSequence = sequences.join("");
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .fasta import√© avec succ√®s !");
            } else {
              alert("Aucune s√©quence ADN trouv√©e dans le fichier .fasta");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .fasta : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour charger la s√©quence de test texte (ancienne logique)
      function loadTestTextSequence() {
        loadTestSequenceOld();
      }

      // Fonction pour charger la s√©quence de test image depuis Dropbox
      async function loadTestImageSequence() {
        const baseUrl =
          "https://www.dropbox.com/scl/fi/0cspsf5bqrsjdk2rb9w4c/Tester-Image-1.fasta?rlkey=mn8da7qqm7r1wwrbgjtptcuqk&st=y3huk9e9";

        // Essayer plusieurs formats d'URL Dropbox (comme pour l'image)
        const urls = [
          baseUrl + "&raw=1",
          baseUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com") +
            "&dl=1",
          "https://dl.dropboxusercontent.com/scl/fi/0cspsf5bqrsjdk2rb9w4c/Tester-Image-1.fasta?rlkey=mn8da7qqm7r1wwrbgjtptcuqk&st=y3huk9e9&dl=1",
        ];

        try {
          // Afficher un message de chargement
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "Chargement...";

          let text = null;
          let lastError = null;

          // Essayer chaque URL jusqu'√† ce qu'une fonctionne
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                text = await response.text();
                break; // Succ√®s, sortir de la boucle
              } else {
                lastError = new Error(`Erreur HTTP: ${response.status}`);
              }
            } catch (err) {
              console.log("Tentative avec URL √©chou√©e:", url, err);
              lastError = err;
              continue; // Essayer l'URL suivante
            }
          }

          if (!text) {
            throw (
              lastError ||
              new Error("Impossible de t√©l√©charger le fichier depuis Dropbox")
            );
          }

          // Parser le fichier FASTA (m√™me logique que importFASTAFile)
          const lines = text.split("\n");
          let sequences = [];

          for (let line of lines) {
            line = line.trim();
            // Ignorer les lignes d'en-t√™te (commencent par >)
            if (line && !line.startsWith(">")) {
              // Extraire uniquement les caract√®res A, T, C, G (ignorer les espaces, retours √† la ligne, etc.)
              const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
              if (sequence.length > 0) {
                sequences.push(sequence);
              }
            }
          }

          if (sequences.length > 0) {
            // Concat√©ner toutes les s√©quences trouv√©es
            const dnaSequence = sequences.join("");
            dnaInput.textContent = dnaSequence;
            colorizeDNAInput();
            alert("Fichier .fasta import√© avec succ√®s depuis Dropbox !");
          } else {
            alert("Aucune s√©quence ADN trouv√©e dans le fichier .fasta");
            dnaInput.textContent = "";
          }
        } catch (error) {
          console.error("Erreur lors du t√©l√©chargement:", error);
          alert(
            "Erreur lors du t√©l√©chargement du fichier .fasta depuis Dropbox : " +
              error.message
          );
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "";
        }
      }

      // Fonction pour charger la s√©quence de test (ancienne version - conserv√©e pour r√©f√©rence)
      function loadTestSequenceOld() {
        // S√©quence ADN de test √† mettre directement dans le champ de d√©codage
        let baseSequence =
          "ATGGGCACACCCACTCTTACAACTTTTGGCAAACTTGGCTTTACAGACCTTGGCACACCCACTCTTACAACTTTTCTTTTCACTGGCGTATTTGCCGTGACTTTTGCTGTGCCCCTTACTTTTACGACTTTTCGTTTCAAGCTCACTTAATTTATTGCTAAACTTACCGACCCCGGCTTTGCTAAAAATACTCGTAAACCCGGCTAA";

        // Nettoyer la s√©quence : retirer les espaces (TTT) qui suivent directement un point (TAA, TAG, TGA)
        // Cela √©vite d'avoir un espace entre deux phrases qui cause un deuxi√®me point
        baseSequence = baseSequence.replace(/(TAA|TAG|TGA)TTT+/g, "$1");

        // S√©quences ADN √† garder encod√©es (√† deviner)
        const sequencesToKeep = [
          "ACAGACCTTGGCACACCCACTCTTACAACT",
          "CGTTTCAAGCTCACT",
          "GCTAAAAATACTCGTAAACCCGGC",
        ];

        // D√©coder temporairement la s√©quence pour trouver les positions des mots
        // On va simuler le d√©codage pour trouver les indices
        const input = baseSequence;
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          alert("S√©quence invalide : pas de codon START (ATG)");
          return;
        }

        // Trouver les positions des s√©quences √† garder
        const wordIndices = new Set();
        let wordIndex = 0;
        let currentWordDNA = "";

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Fin de mot (point)
            if (currentWordDNA) {
              // V√©rifier si cette s√©quence ADN correspond √† une des s√©quences √† garder
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
            // Ignorer les codons stop cons√©cutifs
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3;
              } else {
                break;
              }
            }
          } else if (codon === "TTT") {
            // Espace - fin de mot
            if (currentWordDNA) {
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
          } else {
            // Caract√®re normal - ajouter au mot actuel
            currentWordDNA += codon;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (currentWordDNA) {
          for (const seqToKeep of sequencesToKeep) {
            if (currentWordDNA === seqToKeep) {
              wordIndices.add(wordIndex);
              break;
            }
          }
        }

        // S'assurer que la s√©quence se termine par un seul point (TAA, TAG ou TGA)
        // Retirer tout ce qui suit le dernier point
        let cleanedSequence = baseSequence;
        let lastStopIndex = -1;
        for (let i = cleanedSequence.length - 3; i >= 0; i -= 3) {
          const codon = cleanedSequence.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            lastStopIndex = i;
            // V√©rifier s'il y a des codons stop cons√©cutifs avant
            let j = i - 3;
            while (j >= 0) {
              const prevCodon = cleanedSequence.substring(j, j + 3);
              if (["TAA", "TAG", "TGA"].includes(prevCodon)) {
                lastStopIndex = j;
                j -= 3;
              } else {
                break;
              }
            }
            break;
          }
        }

        if (lastStopIndex !== -1) {
          // Garder seulement jusqu'au dernier point (inclus)
          cleanedSequence = cleanedSequence.substring(0, lastStopIndex + 3);
        }

        // Encoder les positions "√† trou" pour que le d√©codage sache quels mots garder en ADN
        let fullSequence = cleanedSequence;
        if (wordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(wordIndices);
          fullSequence = cleanedSequence + trouPositions;
        }

        // Mettre la s√©quence dans le champ de d√©codage
        // Les marqueurs "√† trou" seront pr√©sents mais masqu√©s visuellement
        const dnaInput = document.getElementById("dnaInput");
        dnaInput.textContent = fullSequence;

        // Masquer visuellement les marqueurs "√† trou" (TGGTGG et ce qui suit) dans le champ d'entr√©e
        setTimeout(() => {
          colorizeDNAInput();
          // Apr√®s le coloriage, masquer la partie avec les marqueurs "√† trou"
          const markerIndex = fullSequence.indexOf(TROU_MARKER);
          if (markerIndex !== -1) {
            // Cr√©er un style pour masquer la partie apr√®s le marqueur
            const visiblePart = fullSequence.substring(0, markerIndex);
            const hiddenPart = fullSequence.substring(markerIndex);
            // Remplacer le contenu pour n'afficher que la partie visible
            // Mais garder la s√©quence compl√®te dans un attribut data pour le d√©codage
            dnaInput.setAttribute("data-full-sequence", fullSequence);
            dnaInput.textContent = visiblePart;
            colorizeDNAInput();
          }
        }, 10);
      }

      // Fonction pour copier l'adresse email dans le presse-papier
      function copyEmailToClipboard() {
        const email = "michawaro.mail@gmail.com";
        navigator.clipboard
          .writeText(email)
          .then(() => {
            // Feedback visuel temporaire
            const icon = document.getElementById("emailIcon");
            const originalTitle = icon.title;
            icon.title = "Copi√© !";
            icon.style.transform = "scale(1.2)";
            setTimeout(() => {
              icon.title = originalTitle;
              icon.style.transform = "scale(1)";
            }, 1000);
          })
          .catch((err) => {
            console.error("Erreur lors de la copie :", err);
            alert("Erreur lors de la copie de l'adresse email");
          });
      }

      // Ouvrir la vid√©o du sc√©nario (Dropbox - mode lecture directe)
      function openScenarioVideo() {
        const url =
          "https://www.dropbox.com/scl/fi/5tp7jra3qf1ycya8j3jqs/Th-1A-C3-Rosalind-Message-final.mp4?rlkey=qwg9xohhya7c7t29cmrwi585f&raw=1";
        window.open(url, "_blank", "noopener,noreferrer");
      }

      // Fonction pour g√©n√©rer tous les triplets possibles (64 triplets)
      function generateAllTriplets() {
        const bases = ["A", "T", "C", "G"];
        const triplets = [];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            for (let k = 0; k < 4; k++) {
              triplets.push(bases[i] + bases[j] + bases[k]);
            }
          }
        }
        return triplets;
      }

      // Fonction pour g√©n√©rer 64 couleurs distinctes
      function generate64Colors() {
        // Palette personnalis√©e avec exactement 64 couleurs
        // AAA (index 0) = Blanc
        const colors = [
          // Blancs (3) - AAA doit √™tre blanc
          "#FFFFFF", // 0 - AAA
          "#F5F5F5", // 1
          "#EAEAEA", // 2

          // Rouges ‚Üí Oranges (1‚Äì10)
          "#5A0F14", // 3
          "#7A1C18", // 4
          "#9E2A1D", // 5
          "#C23B22", // 6
          "#E5532D", // 7
          "#F06A3C", // 8
          "#F5834C", // 9
          "#F89C5C", // 10
          "#FBB56D", // 11
          "#FECB7E", // 12

          // Jaunes (11‚Äì18)
          "#FEE08B", // 13
          "#FEEB9C", // 14
          "#FFF2AE", // 15
          "#FFF7C0", // 16
          "#F3F4B2", // 17
          "#E6EE9C", // 18
          "#D9E785", // 19
          "#CCE16F", // 20

          // Verts (19‚Äì30)
          "#BFD95A", // 21
          "#A9CF5A", // 22
          "#93C55A", // 23
          "#7DBB5A", // 24
          "#67B15A", // 25
          "#52A75A", // 26
          "#3D9D5A", // 27
          "#2F8F5C", // 28
          "#23815E", // 29
          "#1B735F", // 30
          "#16655E", // 31
          "#13575B", // 32

          // Turquoises ‚Üí Cyans (31‚Äì38)
          "#145E63", // 33
          "#166E73", // 34
          "#187F84", // 35
          "#1B9095", // 36
          "#22A1A6", // 37
          "#36B2B7", // 38
          "#4EC3C8", // 39
          "#6AD4D9", // 40

          // Bleus (39‚Äì48)
          "#7BDDE1", // 41
          "#6CC9E0", // 42
          "#5CB4DF", // 43
          "#4C9FDE", // 44
          "#3C8ADD", // 45
          "#2F75CC", // 46
          "#2460BB", // 47
          "#1A4AAA", // 48
          "#123495", // 49
          "#0C1F7F", // 50

          // Violets ‚Üí Magentas (49‚Äì50)
          "#3E1F7F", // 51
          "#6A2E9B", // 52

          // Marrons (3)
          "#5A3A1E", // 53
          "#7A4A2E", // 54
          "#9B6A4A", // 55

          // Noir (1)
          "#000000", // 56

          // Gris (3)
          "#2E2E2E", // 57
          "#7A7A7A", // 58
          "#BFBFBF", // 59

          // Couleurs de transition / √©quilibre visuel (4)
          "#C77D3B", // 60 - ocre
          "#8E6FBF", // 61 - violet doux
          "#4F6D7A", // 62 - bleu ardoise
          "#9FB8A0", // 63 - vert gris√©
        ];

        // S'assurer qu'on a exactement 64 couleurs
        if (colors.length !== 64) {
          console.warn(
            `Attention: la palette contient ${colors.length} couleurs au lieu de 64`
          );
        }

        return colors;
      }

      // Fonction pour g√©n√©rer la palette Van Gogh (64 couleurs)
      // L'index 0 (CCC) doit toujours √™tre blanc pour que la feuille reste blanche lors du changement de palette
      // R√àGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur diff√©rente d'au moins 5 unit√©s RGB de toute autre
      // - Ordre : Blancs, Bleus nuits, Jaunes/Oranges, Blancs chauds/cr√®mes, Gris/Noirs, Marrons/Terres, Violets/Pourpres
      function generateVanGoghColors() {
        const colors = [
          // BLANCS (1 couleur)
          "#FFFFFF", // 0 - CCC (blanc pour que la feuille reste blanche)

          // BLEUS NUITS (13 couleurs)
          "#0B1D51", // 1
          "#0E245F", // 2
          "#102A8C", // 3
          "#132FA3", // 4
          "#1636C8", // 5
          "#1A3BFF", // 6
          "#213FAE", // 7
          "#2346A1", // 8
          "#2C3E9F", // 9
          "#304FFE", // 10
          "#3949AB", // 11
          "#1A237E", // 12
          "#0D1B7E", // 13 - nouveau bleu nuit unique

          // JAUNES / ORANGES (11 couleurs)
          "#FFD200", // 14
          "#FFEA00", // 15
          "#FFC300", // 16
          "#FFB000", // 17
          "#FFA000", // 18
          "#FF9500", // 19
          "#FF9F00", // 20
          "#FFCC33", // 21
          "#FFE066", // 22
          "#F4D03F", // 23
          "#EAC100", // 24

          // BLANCS CHAUDS / CR√àMES (8 couleurs)
          "#FFFDF7", // 25
          "#FFF9E6", // 26
          "#FFF6CC", // 27
          "#FFF2B3", // 28
          "#FDF5E6", // 29
          "#FAF3DD", // 30
          "#FFFBEA", // 31
          "#FFF8DC", // 32

          // GRIS / NOIRS (6 couleurs)
          "#141414", // 33
          "#1C1C1C", // 34
          "#2B2B2B", // 35
          "#3A3A3A", // 36
          "#555555", // 37
          "#666666", // 38 - nouveau gris unique

          // MARRONS / TERRES (7 couleurs)
          "#4A2C1D", // 39
          "#5C4033", // 40
          "#6B3E26", // 41
          "#7A4A2E", // 42
          "#8B5A2B", // 43
          "#A97142", // 44
          "#9B6A3B", // 45 - nouveau marron unique

          // VIOLETS / POURPRES (9 couleurs)
          "#3E2A5A", // 46
          "#4B3B6E", // 47
          "#5E2D79", // 48
          "#6A1B9A", // 49
          "#7B1FA2", // 50
          "#8E24AA", // 51
          "#9370DB", // 52 - violet moyen
          "#5A2040", // 53
          "#7A003C", // 54
          "#9C2542", // 55

          // COMPL√âMENT POUR ATTEINDRE 64 (8 couleurs : 5 verts + or, argent, bronze)
          // 5 VERTS DIFF√âRENTS
          "#046205", // 56 - vert fonc√©
          "#137F41", // 57 - vert moyen
          "#4BB74C", // 58 - vert pastel
          "#2E7D32", // 59 - vert for√™t
          "#66BB6A", // 60 - vert clair
          // M√âTAUX
          "#FFD700", // 61 - or
          "#C0C0C0", // 62 - argent
          "#CD7F32", // 63 - bronze
        ];

        // V√©rification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Van Gogh contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Van Gogh contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // V√©rification de la distance RGB minimale (5 unit√©s)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // V√©rifier que chaque couleur est √† au moins 5 unit√©s de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Fonction pour g√©n√©rer la palette Gustav Klimt (64 couleurs)
      // L'index 0 (GGG) doit toujours √™tre blanc pour que la feuille reste blanche lors du changement de palette
      // R√àGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur diff√©rente d'au moins 5 unit√©s RGB de toute autre
      function generateKlimtColors() {
        const colors = [
          // BLANC (1 couleur) - index 0 doit √™tre blanc pour que la feuille reste blanche
          "#FFFFFF", // 0 - GGG (blanc pour que la feuille reste blanche)

          // COULEURS GUSTAV KLIMT (63 couleurs fournies, num√©rot√©es 1-64 dans la liste)
          // Utilisation des couleurs 2-64 de la liste (la couleur 1 #F2D3CC est remplac√©e par #FFFFFF)
          "#9B7C74", // 1 (couleur 2 de la liste)
          "#F3BDAE", // 2 (couleur 3)
          "#E48E73", // 3 (couleur 4)
          "#F1A58D", // 4 (couleur 5)
          "#30150B", // 5 (couleur 6)
          "#4B3026", // 6 (couleur 7)
          "#5B4035", // 7 (couleur 8)
          "#8A6757", // 8 (couleur 9)
          "#422314", // 9 (couleur 10)
          "#A49B96", // 10 (couleur 11)
          "#DE7B3C", // 11 (couleur 12)
          "#221F1D", // 12 (couleur 13)
          "#75543D", // 13 (couleur 14)
          "#552F12", // 14 (couleur 15)
          "#CBA789", // 15 (couleur 16)
          "#6F4725", // 16 (couleur 17)
          "#633B19", // 17 (couleur 18)
          "#BB8D64", // 18 (couleur 19)
          "#B76419", // 19 (couleur 20)
          "#CA7625", // 20 (couleur 21)
          "#805428", // 21 (couleur 22)
          "#AC7E50", // 22 (couleur 23)
          "#8C6135", // 23 (couleur 24)
          "#965A1C", // 24 (couleur 25)
          "#7C4A16", // 25 (couleur 26)
          "#9C7042", // 26 (couleur 27)
          "#A26B2A", // 27 (couleur 28)
          "#B47B35", // 28 (couleur 29)
          "#F4EDE4", // 29 (couleur 30)
          "#EF941F", // 30 (couleur 31)
          "#E99F3E", // 31 (couleur 32)
          "#C68F41", // 32 (couleur 33)
          "#D2A25B", // 33 (couleur 34)
          "#EDB356", // 34 (couleur 35)
          "#F5AF20", // 35 (couleur 36)
          "#F6BC37", // 36 (couleur 37)
          "#E7C473", // 37 (couleur 38)
          "#F6D451", // 38 (couleur 39)
          "#F8CE18", // 39 (couleur 40)
          "#F8D635", // 40 (couleur 41)
          "#C5C4BE", // 41 (couleur 42)
          "#CABA44", // 42 (couleur 43)
          "#FBF092", // 43 (couleur 44)
          "#FBEB21", // 44 (couleur 45)
          "#FCF163", // 45 (couleur 46)
          "#FCF041", // 46 (couleur 47)
          "#A09B3A", // 47 (couleur 48)
          "#768032", // 48 (couleur 49)
          "#58641F", // 49 (couleur 50)
          "#79955C", // 50 (couleur 51)
          "#90AE74", // 51 (couleur 52)
          "#2D4617", // 52 (couleur 53)
          "#64824C", // 53 (couleur 54)
          "#53703E", // 54 (couleur 55)
          "#A9CC93", // 55 (couleur 56)
          "#3F5C32", // 56 (couleur 57)
          "#4E6259", // 57 (couleur 58)
          "#63787D", // 58 (couleur 59)
          "#33383A", // 59 (couleur 60)
          "#334D76", // 60 (couleur 61)
          "#5872B2", // 61 (couleur 62)
          "#7B95D7", // 62 (couleur 63)
          "#D27FA7", // 63 (couleur 64)
          // Note: La couleur #F2D3CC (couleur 1 de la liste) est remplac√©e par #FFFFFF √† l'index 0
        ];

        // V√©rification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Gustav Klimt contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Gustav Klimt contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // V√©rification de la distance RGB minimale (5 unit√©s)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // V√©rifier que chaque couleur est √† au moins 5 unit√©s de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Fonction pour g√©n√©rer la palette Claude Monet (64 couleurs)
      // L'index 0 (TTT) doit toujours √™tre blanc pour que la feuille reste blanche lors du changement de palette
      // R√àGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur diff√©rente d'au moins 5 unit√©s RGB de toute autre
      function generateMonetColors() {
        const colors = [
          // BLANC (1 couleur) - index 0 doit √™tre blanc pour que la feuille reste blanche
          "#FFFFFF", // 0 - TTT (blanc pour que la feuille reste blanche)

          // COULEURS CLAUDE MONET (63 couleurs fournies, num√©rot√©es 1-64 dans la liste)
          // Utilisation des couleurs 2-64 de la liste (la couleur 1 #B94C43 est remplac√©e par #FFFFFF)
          "#A8635C", // 1 (couleur 2 de la liste)
          "#FFE4E1", // 2 (couleur 3)
          "#9E4737", // 3 (couleur 4)
          "#9A6141", // 4 (couleur 5)
          "#7C6556", // 5 (couleur 6)
          "#FFF5EE", // 6 (couleur 7)
          "#805B39", // 7 (couleur 8)
          "#FFE4C4", // 8 (couleur 9)
          "#FAEBD7", // 9 (couleur 10)
          "#FFEBCD", // 10 (couleur 11)
          "#FFEFD5", // 11 (couleur 12)
          "#867543", // 12 (couleur 13)
          "#736B46", // 13 (couleur 14)
          "#FFFACD", // 14 (couleur 15)
          "#736D35", // 15 (couleur 16)
          "#666341", // 16 (couleur 17)
          "#656133", // 17 (couleur 18)
          "#FFFDD0", // 18 (couleur 19)
          "#949261", // 19 (couleur 20)
          "#767556", // 20 (couleur 21)
          "#7A7B67", // 21 (couleur 22)
          "#718235", // 22 (couleur 23)
          "#545D36", // 23 (couleur 24)
          "#666E50", // 24 (couleur 25)
          "#607139", // 25 (couleur 26)
          "#414937", // 26 (couleur 27)
          "#4F6A3E", // 27 (couleur 28)
          "#3F6138", // 28 (couleur 29)
          "#F5FFF5", // 29 (couleur 30)
          "#F0FFF0", // 30 (couleur 31)
          "#88A589", // 31 (couleur 32)
          "#303C32", // 32 (couleur 33)
          "#2C5738", // 33 (couleur 34)
          "#B6D0C0", // 34 (couleur 35)
          "#F5FFFA", // 35 (couleur 36)
          "#2A2C2B", // 36 (couleur 37)
          "#95B7AD", // 37 (couleur 38)
          "#B8D6D7", // 38 (couleur 39)
          "#9FC5CA", // 39 (couleur 40)
          "#425A5E", // 40 (couleur 41)
          "#8DBBC4", // 41 (couleur 42)
          "#A7CDD9", // 42 (couleur 43)
          "#125E7A", // 43 (couleur 44)
          "#73B1CB", // 44 (couleur 45)
          "#52A0C5", // 45 (couleur 46)
          "#8CBED6", // 46 (couleur 47)
          "#B1D5E9", // 47 (couleur 48)
          "#3598D5", // 48 (couleur 49)
          "#96C5E2", // 49 (couleur 50)
          "#138FDF", // 50 (couleur 51)
          "#7AB8E2", // 51 (couleur 52)
          "#C2DFF3", // 52 (couleur 53)
          "#A2CDEB", // 53 (couleur 54)
          "#65AEE3", // 54 (couleur 55)
          "#4FA4E2", // 55 (couleur 56)
          "#F8F8FF", // 56 (couleur 57)
          "#E6E6FA", // 57 (couleur 58)
          "#F0E6FF", // 58 (couleur 59)
          "#FFF0F5", // 59 (couleur 60)
          "#FFDAE0", // 60 (couleur 61)
          "#DF1A33", // 61 (couleur 62)
          "#D63645", // 62 (couleur 63)
          "#BE2D32", // 63 (couleur 64)
          // Note: La couleur #B94C43 (couleur 1 de la liste) est remplac√©e par #FFFFFF √† l'index 0
        ];

        // V√©rification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Claude Monet contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Claude Monet contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // V√©rification de la distance RGB minimale (5 unit√©s)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // V√©rifier que chaque couleur est √† au moins 5 unit√©s de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Variables globales pour le pixel art
      let pixelArtGrid = []; // Grille 50x50 stockant les indices de couleur
      let currentPaletteType = "AAA"; // Type de palette actuelle : "AAA" (classique) ou "CCC" (Van Gogh)
      let tripletToColorMap = {}; // Mapping triplet -> couleur
      let colorToTripletMap = {}; // Mapping couleur -> triplet
      let colorPalette = []; // Palette de 64 couleurs
      let pixelArtHistory = []; // Historique pour undo/redo
      let pixelBorderColor = "black"; // Couleur de bordure des pixels : "black" ou "white"
      let pixelArtHistoryIndex = -1; // Index actuel dans l'historique
      let currentTool = "paint"; // Outil actuel : "paint", "spray", "erase", "eyedropper", "circle", "square", "triangle", "star"
      let shapeStartPos = null; // Position de d√©part pour les formes
      let shapePreviewGrid = null; // Grille sauvegard√©e avant le dessin de forme (pour pr√©visualisation)
      let brushSize = 1; // Taille du pinceau (en pixels)
      let spraySize = 1; // Taille de l'a√©rographe (en pixels)
      let eraserSize = 1; // Taille de la gomme (en pixels)

      // Fonction pour enregistrer le pixel art (export direct en .fasta)
      async function savePixelArt() {
        // V√©rifier que la s√©quence existe dans dnaOutput
        const output = document.getElementById("dnaOutput");
        if (!output) {
          alert("Erreur : impossible de trouver la s√©quence ADN.");
          return;
        }

        const fullSequence = output.getAttribute("data-dna-sequence");
        if (!fullSequence) {
          alert(
            "Aucune s√©quence √† exporter. Veuillez d'abord cr√©er un dessin."
          );
          return;
        }

        // T√©l√©charger directement sans passer par la modale (compatible mobile/tablette)
        try {
          // Format FASTA : en-t√™te suivi de la s√©quence (60 caract√®res par ligne)
          const fastaContent = `>Sequence_ADN_encodee\n`;
          const sequenceLines = fullSequence.match(/.{1,60}/g) || [
            fullSequence,
          ];
          const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

          // Cr√©er un Blob avec le contenu
          const blob = new Blob([fastaFile], {
            type: "text/plain;charset=utf-8;",
          });

          // Utiliser la fonction utilitaire pour t√©l√©charger
          downloadFile(blob, "sequence_encod√©e.fasta");
        } catch (error) {
          console.error("Erreur lors de l'enregistrement:", error);
          alert("Erreur lors de l'enregistrement du fichier.");
        }
      }

      // Fonction pour v√©rifier si un dessin existe (au moins un pixel n'est pas blanc)
      function hasDrawing() {
        const gridSize = 70;
        if (pixelArtGrid.length === 0) return false;

        for (let i = 0; i < gridSize; i++) {
          if (!pixelArtGrid[i]) continue;
          for (let j = 0; j < gridSize; j++) {
            if (pixelArtGrid[i][j] !== undefined && pixelArtGrid[i][j] !== 0) {
              return true; // Au moins un pixel n'est pas blanc (index 0)
            }
          }
        }
        return false; // Tous les pixels sont blancs
      }

      // Fonction pour charger l'image de la fabrique depuis Dropbox
      async function loadFabriqueImage() {
        const container = document.getElementById("fabriqueImageContainer");
        if (!container) return;

        const dropboxUrl =
          "https://www.dropbox.com/scl/fi/dubr39pke2v6k2xo48o4m/La-fabrique-images.png?rlkey=ms3wb24udc2hfk6gjd78siid2&st=z4lzeiyy&raw=1";

        try {
          // Essayer plusieurs formats d'URL Dropbox
          const urls = [
            dropboxUrl,
            dropboxUrl
              .replace("www.dropbox.com", "dl.dropboxusercontent.com")
              .replace("&raw=1", "&dl=1"),
            "https://dl.dropboxusercontent.com/scl/fi/dubr39pke2v6k2xo48o4m/La-fabrique-images.png?rlkey=ms3wb24udc2hfk6gjd78siid2&st=z4lzeiyy&dl=1",
          ];

          let imageLoaded = false;
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                const blob = await response.blob();
                const imageUrl = URL.createObjectURL(blob);
                const img = document.createElement("img");
                img.src = imageUrl;
                img.alt = "La fabrique";
                img.className = "pixel-art-illustration";
                img.style.maxWidth = "100%";
                img.style.height = "auto";
                img.onload = () => {
                  container.innerHTML = "";
                  container.appendChild(img);
                  imageLoaded = true;
                };
                img.onerror = () => {
                  URL.revokeObjectURL(imageUrl);
                };
                break;
              }
            } catch (err) {
              console.log("Tentative avec URL √©chou√©e:", url, err);
              continue;
            }
          }

          if (!imageLoaded) {
            container.innerHTML =
              '<span style="color: #999; font-size: 0.85rem;">Image non disponible</span>';
          }
        } catch (error) {
          console.error("Erreur lors du chargement de l'image:", error);
          container.innerHTML =
            '<span style="color: #999; font-size: 0.85rem;">Erreur de chargement</span>';
        }
      }

      // Variable globale pour emp√™cher le dessin pendant le zoom
      let isZooming = false;
      let pixelGridCurrentScale = 1;

      // Fonction pour configurer le zoom pinch sur la grille (mobile) et molette (PC)
      function setupPixelGridZoom() {
        const pixelGrid = document.getElementById("pixelGrid");
        if (!pixelGrid) return;

        let initialDistance = 0;
        let minScale = 0.5;
        let maxScale = 3;
        pixelGridCurrentScale = 1;

        // Calculer la distance entre deux points tactiles
        function getDistance(touch1, touch2) {
          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        // Zoom pinch sur mobile/tablette
        pixelGrid.addEventListener(
          "touchstart",
          function (e) {
            if (e.touches.length === 2) {
              e.preventDefault();
              isZooming = true;
              initialDistance = getDistance(e.touches[0], e.touches[1]);
            } else if (e.touches.length === 1) {
              isZooming = false;
            }
          },
          { passive: false }
        );

        pixelGrid.addEventListener(
          "touchmove",
          function (e) {
            if (e.touches.length === 2) {
              e.preventDefault();
              isZooming = true;
              const currentDistance = getDistance(e.touches[0], e.touches[1]);
              if (initialDistance > 0) {
                const scale = currentDistance / initialDistance;
                const newScale = Math.max(
                  minScale,
                  Math.min(maxScale, pixelGridCurrentScale * scale)
                );

                pixelGrid.style.transform = `scale(${newScale})`;
                pixelGrid.style.transformOrigin = "center center";
              }
            } else if (e.touches.length === 1 && isZooming) {
              // Si on passe de 2 doigts √† 1, arr√™ter le zoom
              isZooming = false;
            }
          },
          { passive: false }
        );

        pixelGrid.addEventListener(
          "touchend",
          function (e) {
            if (e.touches.length < 2 && initialDistance > 0) {
              if (pixelGrid.style.transform) {
                const match =
                  pixelGrid.style.transform.match(/scale\(([^)]+)\)/);
                if (match) {
                  pixelGridCurrentScale = parseFloat(match[1]);
                }
              }
              initialDistance = 0;
              // Attendre un peu avant de r√©activer le dessin pour √©viter les trac√©s accidentels
              setTimeout(() => {
                isZooming = false;
              }, 100);
            } else if (e.touches.length === 0) {
              isZooming = false;
            }
          },
          { passive: false }
        );

        // Zoom molette sur PC
        pixelGrid.addEventListener(
          "wheel",
          function (e) {
            e.preventDefault();
            isZooming = true;

            const delta = e.deltaY > 0 ? 0.9 : 1.1; // R√©duire ou augmenter de 10%
            const newScale = Math.max(
              minScale,
              Math.min(maxScale, pixelGridCurrentScale * delta)
            );

            pixelGridCurrentScale = newScale;
            pixelGrid.style.transform = `scale(${newScale})`;
            pixelGrid.style.transformOrigin = "center center";

            // R√©activer le dessin apr√®s un court d√©lai
            setTimeout(() => {
              isZooming = false;
            }, 100);
          },
          { passive: false }
        );
      }

      // Fonction pour fermer le modal pixel art
      function closePixelArtModal() {
        const modal = document.getElementById("pixelArtModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour am√©liorer le bouton d'enregistrement sur mobile/tablette
      function setupSaveButton() {
        const saveBtn = document.getElementById("savePixelArtBtn");
        if (!saveBtn) return;

        // Emp√™cher le double d√©clenchement
        let isSaving = false;
        const handleSave = async function (e) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }

          if (isSaving) return;
          isSaving = true;

          try {
            await savePixelArt();
          } finally {
            setTimeout(() => {
              isSaving = false;
            }, 500);
          }
        };

        // Supprimer les anciens event listeners pour √©viter les doublons
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

        // Ajouter les √©v√©nements pour mobile et desktop
        newSaveBtn.addEventListener("click", handleSave);
        newSaveBtn.addEventListener("touchend", handleSave, { passive: false });
      }

      // Fonction pour am√©liorer le bouton de fermeture sur mobile/tablette
      function setupCloseButton() {
        const closeBtn = document.getElementById("closePixelArtModal");
        if (!closeBtn) return;

        // Emp√™cher le double d√©clenchement
        let isClosing = false;
        const handleClose = function (e) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }

          if (isClosing) return;
          isClosing = true;

          try {
            closePixelArtModal();
          } finally {
            setTimeout(() => {
              isClosing = false;
            }, 300);
          }
        };

        // Supprimer les anciens event listeners pour √©viter les doublons
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

        // Ajouter les √©v√©nements pour mobile et desktop
        newCloseBtn.addEventListener("click", handleClose);
        newCloseBtn.addEventListener("touchend", handleClose, {
          passive: false,
        });
      }

      // Fonction pour am√©liorer tous les boutons pour mobile/tablette
      function setupAllButtonsForMobile() {
        // S√©lectionner tous les boutons
        const allButtons = document.querySelectorAll("button");

        allButtons.forEach((button) => {
          // √âviter de traiter plusieurs fois le m√™me bouton
          if (button.dataset.mobileSetup === "true") return;
          button.dataset.mobileSetup = "true";

          // Ajouter les styles CSS pour mobile
          button.style.touchAction = "manipulation";
          button.style.userSelect = "none";
          button.style.webkitUserSelect = "none";
          button.style.mozUserSelect = "none";
          button.style.msUserSelect = "none";
          button.style.webkitTapHighlightColor = "transparent";

          // S'assurer que le bouton a un cursor pointer
          if (!button.style.cursor || button.style.cursor === "auto") {
            button.style.cursor = "pointer";
          }

          // Ajouter un gestionnaire touchend pour mobile
          // Emp√™cher le double d√©clenchement
          let isHandling = false;

          const handleTouch = function (e) {
            if (isHandling) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }

            isHandling = true;
            e.preventDefault();
            e.stopPropagation();

            // D√©clencher le clic programmatiquement
            button.click();

            setTimeout(() => {
              isHandling = false;
            }, 300);
          };

          // Ajouter l'√©v√©nement touchend
          button.addEventListener("touchend", handleTouch, { passive: false });
        });
      }

      // Fonction pour changer de palette
      function changePalette(paletteType) {
        // V√©rifier si un dessin existe
        if (hasDrawing()) {
          alert(
            "Impossible de changer de palette !\n\n" +
              "Un dessin a d√©j√† √©t√© commenc√© avec la palette actuelle.\n" +
              "Vous devez terminer ou effacer votre dessin (page blanche) avant de pouvoir changer de palette."
          );
          // Remettre le s√©lecteur √† la palette actuelle
          const paletteSelector = document.getElementById("paletteSelector");
          if (paletteSelector) {
            paletteSelector.value = currentPaletteType;
          }
          return; // Emp√™cher le changement
        }

        // Si pas de dessin, permettre le changement
        currentPaletteType = paletteType;
        // Recharger l'√©diteur avec la nouvelle palette
        openPixelArtEditor();
      }

      // Fonction pour ouvrir l'√©diteur pixel art
      function openPixelArtEditor() {
        const modal = document.getElementById("pixelArtModal");
        const content = document.getElementById("pixelArtContent");

        // G√©n√©rer les triplets et les couleurs selon la palette s√©lectionn√©e
        const triplets = generateAllTriplets();
        let colors;
        let paletteName;
        if (currentPaletteType === "CCC") {
          colors = generateVanGoghColors();
          paletteName = "Palette Van Gogh";
        } else if (currentPaletteType === "GGG") {
          colors = generateKlimtColors();
          paletteName = "Palette Gustav Klimt";
        } else if (currentPaletteType === "TTT") {
          colors = generateMonetColors();
          paletteName = "Palette Claude Monet";
        } else {
          colors = generate64Colors();
          paletteName = "Palette classique";
          currentPaletteType = "AAA"; // S'assurer que c'est AAA par d√©faut
        }
        colorPalette = colors;

        // Cr√©er les mappings
        triplets.forEach((triplet, index) => {
          tripletToColorMap[triplet] = colors[index];
          colorToTripletMap[colors[index]] = triplet;
        });

        // Initialiser la grille avec la premi√®re couleur de la palette pour tous les carreaux si elle n'existe pas d√©j√†
        const gridSize = 70;
        if (pixelArtGrid.length === 0 || pixelArtGrid.length !== gridSize) {
          pixelArtGrid = [];
          for (let i = 0; i < gridSize; i++) {
            pixelArtGrid[i] = [];
            for (let j = 0; j < gridSize; j++) {
              pixelArtGrid[i][j] = 0; // Index 0 = premi√®re couleur de la palette
            }
          }
        }

        // Initialiser la s√©quence dans dnaOutput seulement si un dessin existe d√©j√†
        // Sinon, laisser dnaOutput vide pour afficher le message par d√©faut
        const dnaOutput = document.getElementById("dnaOutput");
        if (hasDrawing()) {
          // Si un dessin existe, mettre √† jour la s√©quence
          updateDNASequence();
        } else {
          // Si pas de dessin, vider dnaOutput pour afficher le message par d√©faut
          dnaOutput.textContent = "";
          dnaOutput.removeAttribute("data-dna-sequence");
          // Cacher le label
          updateDnaOutputLabel();
        }

        // Afficher le bouton d'export
        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) exportBtn.style.display = "inline-block";

        // Initialiser l'historique
        pixelArtHistory = [JSON.parse(JSON.stringify(pixelArtGrid))];
        pixelArtHistoryIndex = 0;
        currentTool = "paint";
        shapeStartPos = null;

        // Cr√©er l'interface
        let html = '<div style="display: flex; gap: 20px; flex-wrap: wrap;">';

        // Palette de couleurs (64 couleurs)
        html += '<div style="flex: 0 0 200px;">';
        html += '<div style="margin-bottom: 15px;">';

        // V√©rifier si un dessin existe
        const drawingExists = hasDrawing();
        const disabledStyle = drawingExists
          ? "padding: 8px; border: 2px solid #ccc; border-radius: 6px; font-size: 1rem; width: 100%; background-color: #f5f5f5; color: #999; cursor: not-allowed;"
          : "padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1rem; width: 100%;";

        html +=
          '<label style="display: block; margin-bottom: 5px; font-weight: bold; color: #667eea;">S√©lectionner la palette :</label>';
        html += `<select id="paletteSelector" onchange="changePalette(this.value)" ${
          drawingExists ? "disabled" : ""
        } style="${disabledStyle}">`;
        html += `<option value="AAA" ${
          currentPaletteType === "AAA" ? "selected" : ""
        }>Palette classique (AAA)</option>`;
        html += `<option value="CCC" ${
          currentPaletteType === "CCC" ? "selected" : ""
        }>Palette Van Gogh (CCC)</option>`;
        html += `<option value="GGG" ${
          currentPaletteType === "GGG" ? "selected" : ""
        }>Palette Gustav Klimt (GGG)</option>`;
        html += `<option value="TTT" ${
          currentPaletteType === "TTT" ? "selected" : ""
        }>Palette Claude Monet (TTT)</option>`;
        html += "</select>";

        // Afficher un message d'avertissement si un dessin existe
        if (drawingExists) {
          html +=
            '<div style="margin-top: 8px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 0.85rem; color: #856404;">';
          html +=
            "‚ö†Ô∏è Impossible de changer de palette : un dessin a d√©j√† √©t√© commenc√©.";
          html += "</div>";
        }

        html += "</div>";
        html += `<h3 style="margin-top: 0; color: #667eea;">${paletteName}</h3>`;
        html +=
          '<div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; margin-bottom: 20px;">';
        colors.forEach((color, index) => {
          const triplet = triplets[index];
          html += `<div
            class="color-swatch"
            data-color-index="${index}"
            data-triplet="${triplet}"
            style="
              width: 20px;
              height: 20px;
              background: ${color};
              border: 2px solid #333;
              cursor: pointer;
              border-radius: 3px;
            "
            title="${triplet} - ${color}"
            onclick="selectColor(${index})"
          ></div>`;
        });
        html += "</div>";
        html +=
          '<div id="selectedColorInfo" style="padding: 10px; background: #f0f0f0; border-radius: 6px; margin-top: 10px;">';
        html +=
          '<strong>Triplet s√©lectionn√©:</strong> <span id="selectedTriplet">AAA</span>';
        html += "</div>";
        // Ajouter l'image de la fabrique en dessous de la palette
        html +=
          '<div class="pixel-art-illustration" id="fabriqueImageContainer" style="flex-shrink: 0; max-width: 100%; width: 100%; margin-top: 20px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; border-radius: 8px; min-height: 200px;">';
        html +=
          '<span style="color: #666; font-size: 0.9rem;">Chargement de l\'image...</span>';
        html += "</div>";
        html += "</div>";

        // Grille de pixel art (image maintenant sous la palette)
        html += '<div style="flex: 1; min-width: 500px; width: 100%;">';
        html += '<h3 style="margin-top: 0; color: #667eea;">Grille 70√ó70</h3>';
        html +=
          '<div style="display: flex; flex-direction: column; width: 100%;">';

        // Barre d'outils
        html +=
          '<div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">';
        html +=
          '<button id="undoBtn" onclick="undoPixelArt()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Annuler (Ctrl+Z)">‚Ü∂ Annuler</button>';
        html +=
          '<button id="redoBtn" onclick="redoPixelArt()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Refaire (Ctrl+Y)">‚Ü∑ Refaire</button>';
        html +=
          '<button id="clearBtn" onclick="clearPixelArt()" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Effacer toute la grille">üßº Page blanche</button>';
        html +=
          '<button id="toggleBorderBtn" onclick="togglePixelBorder()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Basculer entre contour blanc et noir">‚ö´ Contour ' +
          (pixelBorderColor === "black" ? "noir" : "blanc") +
          "</button>";
        html +=
          '<div style="width: 1px; height: 30px; background: #ccc; margin: 0 5px;"></div>';
        html +=
          '<button id="paintToolBtn" onclick="openSizeModal(\'brush\')" style="padding: 8px 16px; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Pinceau (Taille: ' +
          brushSize +
          ') - Cliquez pour changer la taille">üñåÔ∏è Pinceau (' +
          brushSize +
          ")</button>";
        html +=
          '<button id="sprayToolBtn" onclick="openSizeModal(\'spray\')" style="padding: 8px 16px; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="A√©rographe (Taille: ' +
          spraySize +
          ') - Cliquez pour changer la taille">üé® A√©rographe (' +
          spraySize +
          ")</button>";
        html +=
          '<button id="eyedropperToolBtn" onclick="selectTool(\'eyedropper\')" style="padding: 8px 16px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Pipette - Cliquez sur un pixel pour pr√©lever sa couleur">üíß Pipette</button>';
        html +=
          '<button id="eraseToolBtn" onclick="openSizeModal(\'eraser\')" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Gomme (Taille: ' +
          eraserSize +
          ') - Cliquez pour changer la taille">üßπ Gomme (' +
          eraserSize +
          ")</button>";
        html += "</div>";

        // Deuxi√®me ligne : Formes g√©om√©triques
        html +=
          '<div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">';
        html +=
          '<button id="circleToolBtn" onclick="selectTool(\'circle\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Cercle - Cliquez et glissez">‚≠ï Cercle</button>';
        html +=
          '<button id="squareToolBtn" onclick="selectTool(\'square\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Carr√© - Cliquez et glissez">‚¨ú Carr√©</button>';
        html +=
          '<button id="triangleToolBtn" onclick="selectTool(\'triangle\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Triangle - Cliquez et glissez">üî∫ Triangle</button>';
        html +=
          '<button id="starToolBtn" onclick="selectTool(\'star\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="√âtoile - Cliquez et glissez">‚≠ê √âtoile</button>';
        html += "</div>";
        html +=
          '<div id="toolStatus" style="margin-bottom: 10px; padding: 8px; background: #f0f0f0; border-radius: 6px; font-size: 0.9rem; color: #666;"></div>';

        // Conteneur pour la grille (image maintenant sous la palette)
        html +=
          '<div id="pixelGrid" style="display: grid; grid-template-columns: repeat(70, 1fr); grid-template-rows: repeat(70, 1fr); gap: 0; background: ' +
          pixelBorderColor +
          '; border: 2px solid #333; padding: 0; width: 100%; aspect-ratio: 1; max-width: 100%; user-select: none; touch-action: pan-x pan-y pinch-zoom; flex: 1; overflow: visible; transition: transform 0.1s ease-out;">';

        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const colorIndex =
              pixelArtGrid[i] && pixelArtGrid[i][j] !== undefined
                ? pixelArtGrid[i][j]
                : 0;
            const color = colors[colorIndex];
            // Bordures uniquement sur le c√¥t√© droit et le bas pour cr√©er un seul trait entre les pixels
            const borderRight =
              j < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
            const borderBottom =
              i < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
            html += `<div
              class="pixel-cell"
              data-row="${i}"
              data-col="${j}"
              style="
                width: 100%;
                height: 100%;
                aspect-ratio: 1;
                background: ${color};
                cursor: crosshair;
                border-right: ${borderRight};
                border-bottom: ${borderBottom};
                touch-action: none;
              "
            ></div>`;
          }
        }
        html += "</div>"; // Fin de pixelGrid
        html += "</div>"; // Fin du conteneur flex de la grille
        html += "</div>"; // Fin du conteneur flex principal

        // Mettre √† jour la s√©quence ADN avec la grille actuelle
        updateDNASequence();

        html += "</div>";

        content.innerHTML = html;
        modal.style.display = "block";

        // Charger l'image de la fabrique depuis Dropbox
        loadFabriqueImage();

        // Configurer le zoom pinch pour la grille sur mobile
        setupPixelGridZoom();

        // Configurer les boutons pour mobile/tablette
        setupSaveButton();
        setupCloseButton();

        // Configurer tous les autres boutons du modal pour mobile/tablette
        setTimeout(setupAllButtonsForMobile, 100);

        // Mettre √† jour le s√©lecteur de palette
        const paletteSelector = document.getElementById("paletteSelector");
        if (paletteSelector) {
          paletteSelector.value = currentPaletteType;
        }

        // Mettre √† jour l'√©tat du s√©lecteur (actif/d√©sactiv√© selon si un dessin existe)
        // Ne pas appeler updatePaletteSelectorState() ici car le message est d√©j√† dans le HTML
        // On met juste √† jour l'√©tat du s√©lecteur sans recr√©er le message
        setTimeout(() => {
          const drawingExists = hasDrawing();
          if (paletteSelector) {
            paletteSelector.disabled = drawingExists;
            if (drawingExists) {
              paletteSelector.style.border = "2px solid #ccc";
              paletteSelector.style.backgroundColor = "#f5f5f5";
              paletteSelector.style.color = "#999";
              paletteSelector.style.cursor = "not-allowed";
            } else {
              paletteSelector.style.border = "2px solid #667eea";
              paletteSelector.style.backgroundColor = "";
              paletteSelector.style.color = "";
              paletteSelector.style.cursor = "";
            }
          }
        }, 100);

        // Initialiser la couleur s√©lectionn√©e (noir par d√©faut, index 56)
        window.selectedColorIndex = 56;
        updateSelectedColorDisplay();
        updateDNASequence();

        // S√©lectionner visuellement la couleur noire dans la palette et le pinceau
        setTimeout(() => {
          selectColor(56);
          selectTool("paint");
        }, 100);

        // Ajouter les event listeners pour les pixels
        setTimeout(() => {
          const pixelCells = document.querySelectorAll(".pixel-cell");
          let isPainting = false;
          let lastPaintRow = -1;
          let lastPaintCol = -1;

          pixelCells.forEach((cell) => {
            // Utiliser l'API Pointer Events pour une meilleure prise en charge des stylets et du tactile
            cell.addEventListener("pointerdown", function (e) {
              // Emp√™cher le dessin pendant le zoom
              if (isZooming) return;

              e.preventDefault();
              const row = parseInt(this.getAttribute("data-row"));
              const col = parseInt(this.getAttribute("data-col"));

              if (
                currentTool === "paint" ||
                currentTool === "spray" ||
                currentTool === "erase" ||
                currentTool === "eyedropper"
              ) {
                if (currentTool === "eyedropper") {
                  // Pour la pipette, pas besoin de capturer le pointeur, juste pr√©lever la couleur
                  pickColorWithEyedropper(row, col);
                } else {
                  isPainting = true;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  paintPixel(row, col);
                  // Capturer le pointeur sur la grille pour une meilleure fluidit√©
                  const pixelGrid = document.getElementById("pixelGrid");
                  if (pixelGrid) {
                    pixelGrid.setPointerCapture(e.pointerId);
                  }
                }
              } else if (
                currentTool === "circle" ||
                currentTool === "square" ||
                currentTool === "triangle" ||
                currentTool === "star"
              ) {
                // Formes g√©om√©triques : clic = point de d√©part, glissement pour ajuster
                isPainting = true;
                shapeStartPos = { row, col };
                // Sauvegarder l'√©tat actuel de la grille pour la pr√©visualisation
                shapePreviewGrid = JSON.parse(JSON.stringify(pixelArtGrid));
                // Capturer le pointeur sur la grille
                const pixelGrid = document.getElementById("pixelGrid");
                if (pixelGrid) {
                  pixelGrid.setPointerCapture(e.pointerId);
                }
              }
            });

            cell.addEventListener("pointerup", function (e) {
              // Lib√©rer le pointeur sur la grille
              const pixelGrid = document.getElementById("pixelGrid");
              if (pixelGrid) {
                pixelGrid.releasePointerCapture(e.pointerId);
              }
              if (isPainting) {
                const row = parseInt(this.getAttribute("data-row"));
                const col = parseInt(this.getAttribute("data-col"));

                if (
                  currentTool === "paint" ||
                  currentTool === "spray" ||
                  currentTool === "erase"
                ) {
                  isPainting = false;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  // Annuler le requestAnimationFrame en cours
                  if (rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                  }
                  // Mettre √† jour la s√©quence ADN et sauvegarder l'historique √† la fin du trait
                  updateDNASequence();
                  saveToHistory();
                } else if (
                  currentTool === "circle" ||
                  currentTool === "square" ||
                  currentTool === "triangle" ||
                  currentTool === "star"
                ) {
                  // Finaliser la forme
                  if (shapeStartPos) {
                    finalizeShape(
                      shapeStartPos.row,
                      shapeStartPos.col,
                      row,
                      col
                    );
                    shapeStartPos = null;
                    shapePreviewGrid = null;
                    isPainting = false;
                    saveToHistory();
                  }
                }
              }
            });

            cell.addEventListener("pointerleave", function (e) {
              // Lib√©rer le pointeur si on sort de la cellule
              if (e.pointerId !== undefined) {
                this.releasePointerCapture(e.pointerId);
              }
            });
          });

          // Gestionnaire pointermove sur la grille enti√®re pour une meilleure fluidit√©
          const pixelGrid = document.getElementById("pixelGrid");
          let rafId = null;
          if (pixelGrid) {
            pixelGrid.addEventListener("pointermove", function (e) {
              // Emp√™cher le dessin pendant le zoom
              if (isZooming) {
                isPainting = false;
                return;
              }

              if (e.buttons === 1 && isPainting) {
                e.preventDefault();

                // Utiliser requestAnimationFrame pour une meilleure fluidit√©
                if (rafId !== null) {
                  cancelAnimationFrame(rafId);
                }

                rafId = requestAnimationFrame(function () {
                  // Trouver la cellule sous le pointeur en utilisant elementFromPoint
                  const element = document.elementFromPoint(
                    e.clientX,
                    e.clientY
                  );
                  if (element && element.classList.contains("pixel-cell")) {
                    const row = parseInt(element.getAttribute("data-row"));
                    const col = parseInt(element.getAttribute("data-col"));

                    if (row >= 0 && row < 70 && col >= 0 && col < 70) {
                      if (
                        currentTool === "paint" ||
                        currentTool === "spray" ||
                        currentTool === "erase"
                      ) {
                        // Interpolation : peindre toutes les cellules entre la derni√®re position et la position actuelle
                        if (lastPaintRow >= 0 && lastPaintCol >= 0) {
                          const dx = col - lastPaintCol;
                          const dy = row - lastPaintRow;
                          const distance = Math.max(Math.abs(dx), Math.abs(dy));

                          if (distance > 1) {
                            // Remplir les trous entre les positions
                            for (let i = 0; i <= distance; i++) {
                              const t = distance > 0 ? i / distance : 0;
                              const interpRow = Math.round(
                                lastPaintRow + dy * t
                              );
                              const interpCol = Math.round(
                                lastPaintCol + dx * t
                              );
                              if (
                                interpRow >= 0 &&
                                interpRow < 70 &&
                                interpCol >= 0 &&
                                interpCol < 70
                              ) {
                                paintPixel(interpRow, interpCol, true);
                              }
                            }
                          } else {
                            paintPixel(row, col, true);
                          }
                        } else {
                          paintPixel(row, col, true);
                        }
                        lastPaintRow = row;
                        lastPaintCol = col;
                      } else if (
                        currentTool === "circle" ||
                        currentTool === "square" ||
                        currentTool === "triangle" ||
                        currentTool === "star"
                      ) {
                        // Restaurer la grille sauvegard√©e puis dessiner la forme
                        if (shapePreviewGrid && shapeStartPos) {
                          pixelArtGrid = JSON.parse(
                            JSON.stringify(shapePreviewGrid)
                          );
                          previewShape(
                            shapeStartPos.row,
                            shapeStartPos.col,
                            row,
                            col
                          );
                        }
                      }
                    }
                  }
                  rafId = null;
                });
              }
            });

            pixelGrid.addEventListener("pointerleave", function (e) {
              if (isPainting) {
                if (
                  currentTool === "paint" ||
                  currentTool === "spray" ||
                  currentTool === "erase"
                ) {
                  isPainting = false;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  // Annuler le requestAnimationFrame en cours
                  if (rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                  }
                  updateDNASequence();
                  saveToHistory();
                } else if (
                  currentTool === "circle" ||
                  currentTool === "square" ||
                  currentTool === "triangle" ||
                  currentTool === "star"
                ) {
                  // Finaliser la forme avec la derni√®re position connue
                  if (shapeStartPos) {
                    // Utiliser la position de d√©part comme position finale si on sort
                    finalizeShape(
                      shapeStartPos.row,
                      shapeStartPos.col,
                      shapeStartPos.row,
                      shapeStartPos.col
                    );
                    shapeStartPos = null;
                    shapePreviewGrid = null;
                    isPainting = false;
                    saveToHistory();
                  }
                }
              }
            });
          }

          // Arr√™ter de peindre si on rel√¢che le pointeur n'importe o√π
          document.addEventListener("pointerup", function (e) {
            // Lib√©rer le pointeur sur la grille
            const pixelGrid = document.getElementById("pixelGrid");
            if (pixelGrid) {
              pixelGrid.releasePointerCapture(e.pointerId);
            }
            if (isPainting) {
              if (
                currentTool === "paint" ||
                currentTool === "spray" ||
                currentTool === "erase"
              ) {
                isPainting = false;
                lastPaintRow = -1;
                lastPaintCol = -1;
                // Annuler le requestAnimationFrame en cours
                if (rafId !== null) {
                  cancelAnimationFrame(rafId);
                  rafId = null;
                }
                updateDNASequence();
                saveToHistory();
              } else if (
                currentTool === "circle" ||
                currentTool === "square" ||
                currentTool === "triangle" ||
                currentTool === "star"
              ) {
                // Finaliser la forme
                if (shapeStartPos) {
                  // Utiliser la position de d√©part comme position finale
                  finalizeShape(
                    shapeStartPos.row,
                    shapeStartPos.col,
                    shapeStartPos.row,
                    shapeStartPos.col
                  );
                  shapeStartPos = null;
                  shapePreviewGrid = null;
                  isPainting = false;
                  saveToHistory();
                }
              }
            }
          });

          // D√©sactiver les actions par d√©faut du navigateur (zoom, s√©lection, etc.)
          if (pixelGrid) {
            pixelGrid.addEventListener(
              "touchstart",
              function (e) {
                if (e.touches.length > 1) {
                  e.preventDefault(); // Emp√™cher le zoom √† deux doigts
                }
              },
              { passive: false }
            );

            pixelGrid.addEventListener(
              "touchmove",
              function (e) {
                if (e.touches.length > 1) {
                  e.preventDefault(); // Emp√™cher le zoom √† deux doigts
                }
              },
              { passive: false }
            );
          }

          // Raccourcis clavier pour undo/redo
          document.addEventListener("keydown", function (e) {
            if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
              e.preventDefault();
              undoPixelArt();
            } else if (
              (e.ctrlKey || e.metaKey) &&
              (e.key === "y" || (e.key === "z" && e.shiftKey))
            ) {
              e.preventDefault();
              redoPixelArt();
            }
          });

          // Initialiser les boutons de taille
          setBrushSize(brushSize);
          setSpraySize(spraySize);
          setEraserSize(eraserSize);

          // Initialiser les boutons d'outils (apr√®s l'initialisation des tailles)
          selectTool("paint");
          updateUndoRedoButtons();

          // Fermer la modale de taille
          const closeSizeModalBtn = document.getElementById("closeSizeModal");
          if (closeSizeModalBtn) {
            closeSizeModalBtn.addEventListener("click", closeSizeModal);
          }
          const sizeModal = document.getElementById("sizeModal");
          if (sizeModal) {
            sizeModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeSizeModal();
              }
            });
          }

          // Fermer les modales d'import/export
          const closeImportModalBtn =
            document.getElementById("closeImportModal");
          if (closeImportModalBtn) {
            closeImportModalBtn.addEventListener("click", closeImportModal);
          }
          const importModal = document.getElementById("importModal");
          if (importModal) {
            importModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeImportModal();
              }
            });
          }

          const closeExportModalBtn =
            document.getElementById("closeExportModal");
          if (closeExportModalBtn) {
            closeExportModalBtn.addEventListener("click", closeExportModal);
          }
          const exportModal = document.getElementById("exportModal");
          if (exportModal) {
            exportModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeExportModal();
              }
            });
          }

          // Event listeners pour la modale de sauvegarde
          const closeSaveFileModalBtn =
            document.getElementById("closeSaveFileModal");
          if (closeSaveFileModalBtn) {
            closeSaveFileModalBtn.addEventListener("click", closeSaveFileModal);
          }
          const saveFileModal = document.getElementById("saveFileModal");
          if (saveFileModal) {
            saveFileModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeSaveFileModal();
              }
            });
          }

          // Permettre d'appuyer sur Entr√©e pour confirmer
          const fileNameInput = document.getElementById("fileNameInput");
          if (fileNameInput) {
            fileNameInput.addEventListener("keypress", function (e) {
              if (e.key === "Enter") {
                confirmSaveFile();
              }
            });
          }
        }, 10);
      }

      // Fonction pour s√©lectionner une couleur
      function selectColor(colorIndex) {
        window.selectedColorIndex = colorIndex;
        updateSelectedColorDisplay();

        // Mettre √† jour l'affichage des swatches
        document.querySelectorAll(".color-swatch").forEach((swatch, index) => {
          if (index === colorIndex) {
            swatch.style.border = "3px solid #667eea";
            swatch.style.transform = "scale(1.1)";
          } else {
            swatch.style.border = "2px solid #333";
            swatch.style.transform = "scale(1)";
          }
        });
      }

      // Fonction pour mettre √† jour l'affichage de la couleur s√©lectionn√©e
      function updateSelectedColorDisplay() {
        const selectedTripletSpan = document.getElementById("selectedTriplet");
        if (selectedTripletSpan && window.selectedColorIndex !== undefined) {
          const triplets = generateAllTriplets();
          selectedTripletSpan.textContent = triplets[window.selectedColorIndex];
        }
      }

      // Fonction pour sauvegarder l'√©tat actuel dans l'historique
      function saveToHistory() {
        // Supprimer les √©tats futurs si on n'est pas √† la fin
        pixelArtHistory = pixelArtHistory.slice(0, pixelArtHistoryIndex + 1);
        // Ajouter le nouvel √©tat
        pixelArtHistory.push(JSON.parse(JSON.stringify(pixelArtGrid)));
        pixelArtHistoryIndex++;
        // Limiter l'historique √† 50 √©tats
        if (pixelArtHistory.length > 50) {
          pixelArtHistory.shift();
          pixelArtHistoryIndex--;
        }
        updateUndoRedoButtons();
        // Mettre √† jour l'√©tat du s√©lecteur de palette apr√®s chaque modification
        updatePaletteSelectorState();
      }

      // Fonction pour annuler
      function undoPixelArt() {
        if (pixelArtHistoryIndex > 0) {
          pixelArtHistoryIndex--;
          pixelArtGrid = JSON.parse(
            JSON.stringify(pixelArtHistory[pixelArtHistoryIndex])
          );
          refreshPixelGrid();
          updateDNASequence();
          updateUndoRedoButtons();
          // Mettre √† jour l'√©tat du s√©lecteur de palette
          updatePaletteSelectorState();
        }
      }

      // Fonction pour refaire
      function redoPixelArt() {
        if (pixelArtHistoryIndex < pixelArtHistory.length - 1) {
          pixelArtHistoryIndex++;
          pixelArtGrid = JSON.parse(
            JSON.stringify(pixelArtHistory[pixelArtHistoryIndex])
          );
          refreshPixelGrid();
          updateDNASequence();
          updateUndoRedoButtons();
          // Mettre √† jour l'√©tat du s√©lecteur de palette
          updatePaletteSelectorState();
        }
      }

      // Fonction pour mettre √† jour les boutons undo/redo
      function updateUndoRedoButtons() {
        const undoBtn = document.getElementById("undoBtn");
        const redoBtn = document.getElementById("redoBtn");
        if (undoBtn) {
          undoBtn.disabled = pixelArtHistoryIndex <= 0;
          undoBtn.style.opacity = undoBtn.disabled ? "0.5" : "1";
        }
        if (redoBtn) {
          redoBtn.disabled = pixelArtHistoryIndex >= pixelArtHistory.length - 1;
          redoBtn.style.opacity = redoBtn.disabled ? "0.5" : "1";
        }
      }

      // Fonction pour s√©lectionner un outil
      function selectTool(tool) {
        currentTool = tool;
        shapeStartPos = null;

        // Mettre √† jour l'apparence des boutons
        const tools = [
          "paint",
          "spray",
          "eyedropper",
          "erase",
          "circle",
          "square",
          "triangle",
          "star",
        ];
        tools.forEach((t) => {
          const btn = document.getElementById(t + "ToolBtn");
          if (btn) {
            if (t === tool) {
              btn.style.background = "#667eea";
              btn.style.transform = "scale(1.05)";
            } else {
              if (t === "paint" || t === "spray")
                btn.style.background = "#51cf66";
              else if (t === "eyedropper") btn.style.background = "#9b59b6";
              else if (t === "erase") btn.style.background = "#ff6b6b";
              else btn.style.background = "#ffa94d";
              btn.style.transform = "scale(1)";
            }
          }
        });

        // Mettre √† jour le message d'√©tat
        const toolStatus = document.getElementById("toolStatus");
        if (toolStatus) {
          if (tool === "paint") {
            toolStatus.textContent =
              "Outil: Pinceau - Cliquez et glissez pour peindre";
          } else if (tool === "spray") {
            toolStatus.textContent =
              "Outil: A√©rographe - Cliquez et glissez pour peindre avec effet spray";
          } else if (tool === "eyedropper") {
            toolStatus.textContent =
              "Outil: Pipette - Cliquez sur un pixel pour pr√©lever sa couleur";
          } else if (tool === "erase") {
            toolStatus.textContent =
              "Outil: Gomme - Cliquez et glissez pour effacer (remet en blanc)";
          } else if (tool === "circle") {
            toolStatus.textContent =
              "Outil: Cercle - Cliquez et glissez pour dessiner un cercle";
          } else if (tool === "square") {
            toolStatus.textContent =
              "Outil: Carr√© - Cliquez et glissez pour dessiner un carr√©";
          } else if (tool === "triangle") {
            toolStatus.textContent =
              "Outil: Triangle - Cliquez et glissez pour dessiner un triangle √©quilat√©ral";
          } else if (tool === "star") {
            toolStatus.textContent =
              "Outil: √âtoile - Cliquez et glissez pour dessiner une √©toile";
          }
        }
      }

      // Fonction pour rafra√Æchir l'affichage de la grille
      function refreshPixelGrid() {
        for (let i = 0; i < 70; i++) {
          for (let j = 0; j < 70; j++) {
            const pixel = document.querySelector(
              `.pixel-cell[data-row="${i}"][data-col="${j}"]`
            );
            if (pixel) {
              const colorIndex =
                pixelArtGrid[i] && pixelArtGrid[i][j] !== undefined
                  ? pixelArtGrid[i][j]
                  : 0;
              pixel.style.background = colorPalette[colorIndex];
              pixel.style.border = `1px solid ${pixelBorderColor}`;
            }
          }
        }
      }

      // Fonction pour basculer la couleur de bordure des pixels
      function togglePixelBorder() {
        // Basculer entre noir et blanc
        pixelBorderColor = pixelBorderColor === "black" ? "white" : "black";

        // Mettre √† jour tous les pixels avec les nouvelles bordures (droite et bas uniquement)
        const pixels = document.querySelectorAll(".pixel-cell");
        const gridSize = 70;
        pixels.forEach((pixel) => {
          const row = parseInt(pixel.getAttribute("data-row"));
          const col = parseInt(pixel.getAttribute("data-col"));
          const borderRight =
            col < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
          const borderBottom =
            row < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
          pixel.style.borderRight = borderRight;
          pixel.style.borderBottom = borderBottom;
          pixel.style.borderTop = "none";
          pixel.style.borderLeft = "none";
        });

        // Mettre √† jour le fond de la grille pour correspondre √† la couleur de bordure
        const pixelGrid = document.getElementById("pixelGrid");
        if (pixelGrid) {
          pixelGrid.style.background = pixelBorderColor;
        }

        // Mettre √† jour le texte du bouton
        const toggleBtn = document.getElementById("toggleBorderBtn");
        if (toggleBtn) {
          toggleBtn.textContent = `‚ö´ Contour ${
            pixelBorderColor === "black" ? "noir" : "blanc"
          }`;
        }
      }

      // Fonction pour mettre √† jour un pixel sp√©cifique dans l'affichage
      function updatePixelDisplay(row, col) {
        const pixel = document.querySelector(
          `.pixel-cell[data-row="${row}"][data-col="${col}"]`
        );
        if (pixel) {
          const colorIndex =
            pixelArtGrid[row] && pixelArtGrid[row][col] !== undefined
              ? pixelArtGrid[row][col]
              : 0;
          pixel.style.background = colorPalette[colorIndex];
        }
      }

      // Fonction pour pr√©lever une couleur avec la pipette
      function pickColorWithEyedropper(row, col) {
        if (row < 0 || row >= 70 || col < 0 || col >= 70) return;

        const colorIndex =
          pixelArtGrid[row] && pixelArtGrid[row][col] !== undefined
            ? pixelArtGrid[row][col]
            : 0;

        // S√©lectionner cette couleur dans la palette
        selectColor(colorIndex);

        // Mettre √† jour le message d'√©tat
        const toolStatus = document.getElementById("toolStatus");
        if (toolStatus) {
          const triplets = generateAllTriplets();
          const triplet = triplets[colorIndex];
          const color = colorPalette[colorIndex];
          toolStatus.textContent = `Couleur pr√©lev√©e : ${triplet} (${color})`;
        }
      }

      // Fonction pour peindre un pixel (ou une zone selon la taille)
      function paintPixel(row, col, skipHistory = false) {
        // Si l'outil pipette est s√©lectionn√©, pr√©lever la couleur au lieu de peindre
        if (currentTool === "eyedropper") {
          pickColorWithEyedropper(row, col);
          return;
        }

        if (currentTool === "paint") {
          if (window.selectedColorIndex === undefined) return;
          const size = brushSize;
          const halfSize = Math.floor(size / 2);
          // Peindre un carr√© centr√© sur le pixel
          for (
            let i = Math.max(0, row - halfSize);
            i <= Math.min(69, row + halfSize);
            i++
          ) {
            for (
              let j = Math.max(0, col - halfSize);
              j <= Math.min(69, col + halfSize);
              j++
            ) {
              pixelArtGrid[i][j] = window.selectedColorIndex;
              // Mettre √† jour uniquement ce pixel dans l'affichage
              updatePixelDisplay(i, j);
            }
          }
        } else if (currentTool === "spray") {
          if (window.selectedColorIndex === undefined) return;
          const size = spraySize;
          const radius = size;
          // A√©rographe : peindre al√©atoirement quelques pixels dans un cercle
          const sprayDensity = 0.25; // 25% de densit√©
          const numPixels = Math.max(
            1,
            Math.floor(Math.PI * radius * radius * sprayDensity)
          );

          for (let n = 0; n < numPixels; n++) {
            // G√©n√©rer un point al√©atoire dans un cercle
            const angle = Math.random() * 2 * Math.PI;
            const distance = Math.random() * radius;
            const randomRow = Math.round(row + distance * Math.cos(angle));
            const randomCol = Math.round(col + distance * Math.sin(angle));

            if (
              randomRow >= 0 &&
              randomRow < 70 &&
              randomCol >= 0 &&
              randomCol < 70
            ) {
              // Probabilit√© d√©croissante avec la distance du centre (effet spray r√©aliste)
              const distFromCenter = Math.sqrt(
                Math.pow(randomRow - row, 2) + Math.pow(randomCol - col, 2)
              );
              const probability = Math.max(0, 1 - distFromCenter / radius);
              if (Math.random() < probability) {
                pixelArtGrid[randomRow][randomCol] = window.selectedColorIndex;
                updatePixelDisplay(randomRow, randomCol);
              }
            }
          }
        } else if (currentTool === "erase") {
          const size = eraserSize;
          const halfSize = Math.floor(size / 2);
          // Effacer un carr√© centr√© sur le pixel
          for (
            let i = Math.max(0, row - halfSize);
            i <= Math.min(69, row + halfSize);
            i++
          ) {
            for (
              let j = Math.max(0, col - halfSize);
              j <= Math.min(69, col + halfSize);
              j++
            ) {
              pixelArtGrid[i][j] = 0; // Blanc (AAA)
              updatePixelDisplay(i, j);
            }
          }
        } else {
          // Pour les formes, on g√®re diff√©remment
          return;
        }

        // Mettre √† jour la s√©quence ADN seulement si on n'a pas demand√© de skip
        if (!skipHistory) {
          // Utiliser un debounce pour √©viter trop de mises √† jour
          clearTimeout(window.dnaUpdateTimeout);
          window.dnaUpdateTimeout = setTimeout(() => {
            updateDNASequence();
          }, 200);

          // Sauvegarder dans l'historique avec debounce
          clearTimeout(window.paintTimeout);
          window.paintTimeout = setTimeout(() => {
            saveToHistory();
          }, 300);
        }
      }

      // Fonction pour effacer toute la grille (page blanche)
      // Fonction pour mettre √† jour l'√©tat du s√©lecteur de palette
      function updatePaletteSelectorState() {
        const paletteSelector = document.getElementById("paletteSelector");
        if (!paletteSelector) return;

        const drawingExists = hasDrawing();
        if (drawingExists) {
          paletteSelector.disabled = true;
          paletteSelector.style.border = "2px solid #ccc";
          paletteSelector.style.backgroundColor = "#f5f5f5";
          paletteSelector.style.color = "#999";
          paletteSelector.style.cursor = "not-allowed";

          // V√©rifier si le message d'avertissement existe d√©j√† (soit dans le HTML g√©n√©r√©, soit cr√©√© dynamiquement)
          let warningMsg =
            paletteSelector.parentElement.querySelector(".palette-warning") ||
            paletteSelector.parentElement.querySelector(
              'div[style*="background-color: #fff3cd"]'
            );
          if (!warningMsg) {
            warningMsg = document.createElement("div");
            warningMsg.className = "palette-warning";
            warningMsg.style.cssText =
              "margin-top: 8px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 0.85rem; color: #856404;";
            warningMsg.textContent =
              "‚ö†Ô∏è Impossible de changer de palette : un dessin a d√©j√† √©t√© commenc√©.";
            paletteSelector.parentElement.appendChild(warningMsg);
          }
        } else {
          paletteSelector.disabled = false;
          paletteSelector.style.border = "2px solid #667eea";
          paletteSelector.style.backgroundColor = "";
          paletteSelector.style.color = "";
          paletteSelector.style.cursor = "";

          // Supprimer le message d'avertissement (soit cr√©√© dynamiquement, soit dans le HTML)
          const warningMsg =
            paletteSelector.parentElement.querySelector(".palette-warning") ||
            paletteSelector.parentElement.querySelector(
              'div[style*="background-color: #fff3cd"]'
            );
          if (warningMsg) {
            warningMsg.remove();
          }
        }
      }

      function clearPixelArt() {
        if (
          confirm(
            "Voulez-vous effacer toute la grille ? Cette action ne peut pas √™tre annul√©e."
          )
        ) {
          const gridSize = 70;
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              pixelArtGrid[i][j] = 0; // Blanc (AAA)
            }
          }
          refreshPixelGrid();
          updateDNASequence();
          // R√©initialiser l'historique avec cette nouvelle grille
          pixelArtHistory = [JSON.parse(JSON.stringify(pixelArtGrid))];
          pixelArtHistoryIndex = 0;
          updateUndoRedoButtons();
          // R√©activer le s√©lecteur de palette car le dessin est effac√©
          updatePaletteSelectorState();
        }
      }

      // Fonction pour d√©finir la taille du pinceau
      function setBrushSize(size) {
        brushSize = size;
        // Mettre √† jour le texte du bouton
        const btn = document.getElementById("paintToolBtn");
        if (btn) {
          btn.textContent = "üñåÔ∏è Pinceau (" + size + ")";
          btn.title =
            "Pinceau (Taille: " + size + ") - Cliquez pour changer la taille";
        }
        // S√©lectionner l'outil si ce n'est pas d√©j√† fait
        if (currentTool !== "paint") {
          selectTool("paint");
        }
        closeSizeModal();
      }

      // Fonction pour d√©finir la taille de la gomme
      function setEraserSize(size) {
        eraserSize = size;
        // Mettre √† jour le texte du bouton
        const btn = document.getElementById("eraseToolBtn");
        if (btn) {
          btn.textContent = "üßπ Gomme (" + size + ")";
          btn.title =
            "Gomme (Taille: " + size + ") - Cliquez pour changer la taille";
        }
        // S√©lectionner l'outil si ce n'est pas d√©j√† fait
        if (currentTool !== "erase") {
          selectTool("erase");
        }
        closeSizeModal();
      }

      // Fonction pour d√©finir la taille de l'a√©rographe
      function setSpraySize(size) {
        spraySize = size;
        // Mettre √† jour le texte du bouton
        const btn = document.getElementById("sprayToolBtn");
        if (btn) {
          btn.textContent = "üé® A√©rographe (" + size + ")";
          btn.title =
            "A√©rographe (Taille: " +
            size +
            ") - Cliquez pour changer la taille";
        }
        // S√©lectionner l'outil si ce n'est pas d√©j√† fait
        if (currentTool !== "spray") {
          selectTool("spray");
        }
        closeSizeModal();
      }

      // Fonction pour ouvrir la modale de choix de taille
      function openSizeModal(toolType) {
        const modal = document.getElementById("sizeModal");
        const content = document.getElementById("sizeModalContent");
        const title = document.getElementById("sizeModalTitle");

        if (!modal || !content || !title) return;

        let currentSize = 1;
        let toolName = "";
        if (toolType === "brush") {
          currentSize = brushSize;
          toolName = "Pinceau";
        } else if (toolType === "spray") {
          currentSize = spraySize;
          toolName = "A√©rographe";
        } else if (toolType === "eraser") {
          currentSize = eraserSize;
          toolName = "Gomme";
        }

        title.textContent = "Choisir la taille - " + toolName;
        content.innerHTML = "";

        for (let i = 1; i <= 10; i++) {
          const btn = document.createElement("button");
          btn.textContent = i;
          btn.style.padding = "15px";
          btn.style.border = "2px solid #ccc";
          btn.style.borderRadius = "8px";
          btn.style.cursor = "pointer";
          btn.style.fontSize = "1.2rem";
          btn.style.fontWeight = "bold";
          if (i === currentSize) {
            btn.style.background = "#667eea";
            btn.style.color = "white";
            btn.style.borderColor = "#667eea";
          } else {
            btn.style.background = "white";
            btn.style.color = "#333";
            btn.style.borderColor = "#ccc";
          }
          btn.onclick = function () {
            if (toolType === "brush") {
              setBrushSize(i);
            } else if (toolType === "spray") {
              setSpraySize(i);
            } else if (toolType === "eraser") {
              setEraserSize(i);
            }
          };
          content.appendChild(btn);
        }

        modal.style.display = "block";
      }

      // Fonction pour fermer la modale de taille
      function closeSizeModal() {
        const modal = document.getElementById("sizeModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour dessiner un cercle
      function drawCircle(
        centerRow,
        centerCol,
        radius,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        for (let i = 0; i < 70; i++) {
          for (let j = 0; j < 70; j++) {
            const dx = j - centerCol;
            const dy = i - centerRow;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= radius) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner un carr√©
      function drawSquare(
        startRow,
        startCol,
        endRow,
        endCol,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        const minRow = Math.min(startRow, endRow);
        const maxRow = Math.max(startRow, endRow);
        const minCol = Math.min(startCol, endCol);
        const maxCol = Math.max(startCol, endCol);

        for (let i = minRow; i <= maxRow && i < 70; i++) {
          for (let j = minCol; j <= maxCol && j < 70; j++) {
            pixelArtGrid[i][j] = colorIndex;
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner un triangle
      function drawTriangle(
        row1,
        col1,
        row2,
        col2,
        row3,
        col3,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }

        // Calculer les limites
        const minRow = Math.min(row1, row2, row3);
        const maxRow = Math.max(row1, row2, row3);
        const minCol = Math.min(col1, col2, col3);
        const maxCol = Math.max(col1, col2, col3);

        // Fonction pour v√©rifier si un point est dans le triangle
        function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
          const d1 = sign(px, py, x1, y1, x2, y2);
          const d2 = sign(px, py, x2, y2, x3, y3);
          const d3 = sign(px, py, x3, y3, x1, y1);
          const hasNeg = d1 < 0 || d2 < 0 || d3 < 0;
          const hasPos = d1 > 0 || d2 > 0 || d3 > 0;
          return !(hasNeg && hasPos);
        }

        function sign(x1, y1, x2, y2, x3, y3) {
          return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);
        }

        for (let i = minRow; i <= maxRow && i < 70; i++) {
          for (let j = minCol; j <= maxCol && j < 70; j++) {
            if (pointInTriangle(j, i, col1, row1, col2, row2, col3, row3)) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner une √©toile
      function drawStar(
        centerRow,
        centerCol,
        outerRadius,
        innerRadius,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        const points = 5; // √âtoile √† 5 branches

        // Calculer les points de l'√©toile
        const starPoints = [];
        for (let i = 0; i < points * 2; i++) {
          const angle = (i * Math.PI) / points;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const x = centerCol + radius * Math.cos(angle - Math.PI / 2);
          const y = centerRow + radius * Math.sin(angle - Math.PI / 2);
          starPoints.push({ x: Math.round(x), y: Math.round(y) });
        }

        // Remplir l'√©toile en utilisant un polygone
        const minRow = Math.max(0, Math.min(...starPoints.map((p) => p.y)) - 2);
        const maxRow = Math.min(
          69,
          Math.max(...starPoints.map((p) => p.y)) + 2
        );
        const minCol = Math.max(0, Math.min(...starPoints.map((p) => p.x)) - 2);
        const maxCol = Math.min(
          69,
          Math.max(...starPoints.map((p) => p.x)) + 2
        );

        for (let i = minRow; i <= maxRow; i++) {
          for (let j = minCol; j <= maxCol; j++) {
            if (pointInPolygon(j, i, starPoints)) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour v√©rifier si un point est dans un polygone
      function pointInPolygon(x, y, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x,
            yi = points[i].y;
          const xj = points[j].x,
            yj = points[j].y;
          const intersect =
            yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // Fonction pour pr√©visualiser une forme (sans sauvegarder dans l'historique)
      function previewShape(startRow, startCol, endRow, endCol) {
        // Restaurer la grille sauvegard√©e avant de dessiner
        if (shapePreviewGrid) {
          pixelArtGrid = JSON.parse(JSON.stringify(shapePreviewGrid));
        }

        const colorIndex =
          currentTool === "erase"
            ? 0
            : window.selectedColorIndex !== undefined
            ? window.selectedColorIndex
            : 0;

        if (currentTool === "circle") {
          const radius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          drawCircle(startRow, startCol, radius, colorIndex, true);
        } else if (currentTool === "square") {
          drawSquare(startRow, startCol, endRow, endCol, colorIndex, true);
        } else if (currentTool === "triangle") {
          const centerRow = startRow;
          const centerCol = startCol;
          const point2Row = endRow;
          const point2Col = endCol;
          const dx = point2Col - centerCol;
          const dy = point2Row - centerRow;
          const point3Row = centerRow - dy;
          const point3Col = centerCol + dx;
          drawTriangle(
            centerRow,
            centerCol,
            point2Row,
            point2Col,
            point3Row,
            point3Col,
            colorIndex,
            true
          );
        } else if (currentTool === "star") {
          const outerRadius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          const innerRadius = Math.floor(outerRadius * 0.4);
          drawStar(
            startRow,
            startCol,
            outerRadius,
            innerRadius,
            colorIndex,
            true
          );
        }
      }

      // Fonction pour finaliser une forme (sauvegarder dans l'historique)
      function finalizeShape(startRow, startCol, endRow, endCol) {
        const colorIndex =
          currentTool === "erase"
            ? 0
            : window.selectedColorIndex !== undefined
            ? window.selectedColorIndex
            : 0;

        if (currentTool === "circle") {
          const radius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          drawCircle(startRow, startCol, radius, colorIndex, false);
        } else if (currentTool === "square") {
          drawSquare(startRow, startCol, endRow, endCol, colorIndex, false);
        } else if (currentTool === "triangle") {
          const centerRow = startRow;
          const centerCol = startCol;
          const point2Row = endRow;
          const point2Col = endCol;
          const dx = point2Col - centerCol;
          const dy = point2Row - centerRow;
          const point3Row = centerRow - dy;
          const point3Col = centerCol + dx;
          drawTriangle(
            centerRow,
            centerCol,
            point2Row,
            point2Col,
            point3Row,
            point3Col,
            colorIndex,
            false
          );
        } else if (currentTool === "star") {
          const outerRadius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          const innerRadius = Math.floor(outerRadius * 0.4);
          drawStar(
            startRow,
            startCol,
            outerRadius,
            innerRadius,
            colorIndex,
            false
          );
        }
      }

      // Fonction pour mettre √† jour la s√©quence ADN dans dnaOutput
      function updateDNASequence() {
        const triplets = generateAllTriplets();
        let sequence = "";

        // Parcourir la grille ligne par ligne
        for (let i = 0; i < 70; i++) {
          for (let j = 0; j < 70; j++) {
            const colorIndex = pixelArtGrid[i][j];
            const triplet = triplets[colorIndex];
            sequence += triplet;
          }
        }

        // Ajouter le triplet de palette au d√©but (14703 nucl√©otides au total)
        const fullSequence = currentPaletteType + sequence;

        // Mettre √† jour dnaOutput
        const dnaOutput = document.getElementById("dnaOutput");
        dnaOutput.textContent = fullSequence;
        dnaOutput.setAttribute("data-dna-sequence", fullSequence);

        // Afficher le bouton d'export
        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) exportBtn.style.display = "inline-block";

        // Afficher le label
        updateDnaOutputLabel();
      }

      // Fonction pour charger une s√©quence ADN dans l'√©diteur pixel art
      function loadPixelArtFromSequence(sequence) {
        const triplets = generateAllTriplets();
        const gridSize = 70;

        // V√©rifier que la s√©quence a la bonne longueur (14700 ou 14703 nucl√©otides)
        let paletteTriplet = "AAA"; // Par d√©faut
        let imageSequence = sequence;

        if (sequence.length === 14703) {
          // La s√©quence contient le triplet de palette au d√©but
          paletteTriplet = sequence.substring(0, 3);
          imageSequence = sequence.substring(3); // Le reste de la s√©quence (14700 nucl√©otides)
          // Valider que le triplet de palette est valide (AAA, CCC, GGG, ou TTT)
          if (
            paletteTriplet === "AAA" ||
            paletteTriplet === "CCC" ||
            paletteTriplet === "GGG" ||
            paletteTriplet === "TTT"
          ) {
            currentPaletteType = paletteTriplet;
          } else {
            alert(
              `Triplet de palette invalide : ${paletteTriplet}. Utilisation de la palette classique (AAA) par d√©faut.`
            );
            currentPaletteType = "AAA";
          }
        } else if (sequence.length === 14700) {
          // Pas de triplet de palette, utiliser AAA par d√©faut
          currentPaletteType = "AAA";
          imageSequence = sequence;
        } else {
          alert(
            "La s√©quence doit faire exactement 14700 nucl√©otides (4900 triplets) ou 14703 nucl√©otides (1 triplet de palette + 4900 triplets) pour √™tre une image pixel art."
          );
          return;
        }

        // Extraire les triplets et trouver leurs indices dans la palette
        pixelArtGrid = [];
        for (let i = 0; i < gridSize; i++) {
          pixelArtGrid[i] = [];
          for (let j = 0; j < gridSize; j++) {
            const tripletIndex = i * gridSize + j;
            const triplet = imageSequence.substring(
              tripletIndex * 3,
              tripletIndex * 3 + 3
            );
            const colorIndex = triplets.indexOf(triplet);
            if (colorIndex === -1) {
              // Triplet non trouv√©, utiliser l'index 0 par d√©faut
              pixelArtGrid[i][j] = 0;
            } else {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }

        // Ouvrir l'√©diteur avec la grille charg√©e
        openPixelArtEditor();
        // Mettre √† jour l'√©tat du s√©lecteur de palette apr√®s le chargement
        // Ne pas appeler updatePaletteSelectorState() car le message est d√©j√† dans le HTML g√©n√©r√©
        // On met juste √† jour l'√©tat du s√©lecteur sans recr√©er le message
        setTimeout(() => {
          const paletteSelector = document.getElementById("paletteSelector");
          if (paletteSelector) {
            const drawingExists = hasDrawing();
            paletteSelector.disabled = drawingExists;
            if (drawingExists) {
              paletteSelector.style.border = "2px solid #ccc";
              paletteSelector.style.backgroundColor = "#f5f5f5";
              paletteSelector.style.color = "#999";
              paletteSelector.style.cursor = "not-allowed";
            } else {
              paletteSelector.style.border = "2px solid #667eea";
              paletteSelector.style.backgroundColor = "";
              paletteSelector.style.color = "";
              paletteSelector.style.cursor = "";
            }
          }
        }, 100);
      }

      // Fonction pour cr√©er les mosa√Øques color√©es sur le bouton pixel art
      function createPixelArtMosaic() {
        const mosaicContainer = document.getElementById("pixelArtMosaic");
        if (!mosaicContainer) return;

        // Couleurs vari√©es pour les mosa√Øques
        const mosaicColors = [
          "#FF6B6B",
          "#4ECDC4",
          "#45B7D1",
          "#FFA07A",
          "#98D8C8",
          "#F7DC6F",
          "#BB8FCE",
          "#85C1E2",
          "#F8B739",
          "#E74C3C",
          "#3498DB",
          "#2ECC71",
          "#9B59B6",
          "#1ABC9C",
          "#E67E22",
          "#34495E",
          "#FFD700",
          "#FF6347",
          "#00CED1",
          "#9370DB",
          "#FF1493",
          "#00FF7F",
          "#FF4500",
          "#1E90FF",
          "#FF69B4",
          "#32CD32",
          "#FF8C00",
          "#8A2BE2",
          "#DC143C",
          "#00FA9A",
          "#FFD700",
          "#FF1493",
          "#00CED1",
          "#9370DB",
          "#FF6347",
          "#00FF7F",
        ];

        // Cr√©er 32 carreaux (8x4)
        for (let i = 0; i < 32; i++) {
          const tile = document.createElement("div");
          const colorIndex = Math.floor(Math.random() * mosaicColors.length);
          tile.style.backgroundColor = mosaicColors[colorIndex];
          tile.style.border = "none";
          mosaicContainer.appendChild(tile);
        }
      }

      // Fonction pour exporter le code g√©n√©tique en CSV
      function exportGeneticCode() {
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));

        // Cr√©er le contenu CSV
        let csvContent = "Codon,Symbole\n";
        entries.forEach(([codon, symbol]) => {
          // √âchapper les virgules et guillemets dans les symboles
          const escapedSymbol =
            symbol.includes(",") || symbol.includes('"')
              ? `"${symbol.replace(/"/g, '""')}"`
              : symbol;
          csvContent += `${codon},${escapedSymbol}\n`;
        });

        // Cr√©er un blob et t√©l√©charger
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        downloadFile(blob, "code_genetique.csv");
      }

      // Fonction pour importer le code g√©n√©tique depuis un CSV
      function importGeneticCode(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const lines = text.split("\n").filter((line) => line.trim() !== "");

            // Ignorer la premi√®re ligne (en-t√™te)
            const dataLines = lines.slice(1);

            // Cr√©er un nouveau code g√©n√©tique
            const newGeneticCode = { ATG: "START" };
            let hasError = false;
            let errorMessage = "";

            dataLines.forEach((line, index) => {
              // Parser la ligne CSV (g√©rer les virgules dans les valeurs)
              const match = line.match(/^([^,]+),(".*"|[^,]*)$/);
              if (match) {
                const codon = match[1].trim();
                let symbol = match[2].trim();

                // Enlever les guillemets si pr√©sents
                if (symbol.startsWith('"') && symbol.endsWith('"')) {
                  symbol = symbol.slice(1, -1).replace(/""/g, '"');
                }

                // Valider le codon (3 lettres A, T, C, G)
                if (/^[ATCG]{3}$/.test(codon)) {
                  newGeneticCode[codon] = symbol;
                } else {
                  hasError = true;
                  errorMessage += `Ligne ${
                    index + 2
                  }: Codon invalide "${codon}"\n`;
                }
              } else if (line.trim() !== "") {
                hasError = true;
                errorMessage += `Ligne ${index + 2}: Format invalide\n`;
              }
            });

            if (hasError) {
              alert("Erreurs lors de l'importation :\n" + errorMessage);
              return;
            }

            // Demander confirmation avant de remplacer
            if (
              confirm(
                "Voulez-vous remplacer le code g√©n√©tique actuel par celui du fichier CSV ?"
              )
            ) {
              // Remplacer le code g√©n√©tique
              Object.keys(geneticCode).forEach((key) => {
                if (key !== "ATG") delete geneticCode[key];
              });
              Object.assign(geneticCode, newGeneticCode);

              // Reconstruire le reverseCode global
              Object.keys(reverseCode).forEach(
                (key) => delete reverseCode[key]
              );
              for (let [codon, char] of Object.entries(geneticCode)) {
                if (char !== "START" && char !== "Majuscule") {
                  if (!reverseCode[char]) reverseCode[char] = [];
                  reverseCode[char].push(codon);
                }
              }

              // Recharger le tableau
              const tbody = document.getElementById("codeTable");
              tbody.innerHTML = "";
              const entries = Object.entries(geneticCode)
                .filter(([k, v]) => v !== "START")
                .sort(([a], [b]) => a.localeCompare(b));

              const numColumns = 4;
              const entriesPerColumn = Math.ceil(entries.length / numColumns);

              const rows = [];
              for (let i = 0; i < entriesPerColumn; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < numColumns * 2; j++) {
                  const cell = document.createElement("td");
                  row.appendChild(cell);
                }
                rows.push(row);
                tbody.appendChild(row);
              }

              entries.forEach(([codon, symbol], index) => {
                const columnIndex = Math.floor(index / entriesPerColumn);
                const rowIndex = index % entriesPerColumn;
                if (columnIndex >= numColumns) return;
                const row = rows[rowIndex];
                const codonCellIndex = columnIndex * 2;
                const symbolCellIndex = codonCellIndex + 1;
                row.cells[codonCellIndex].textContent = codon;
                row.cells[symbolCellIndex].textContent = symbol;

                // Colorer les codons stop en rose pastel
                if (["TAA", "TAG", "TGA"].includes(codon)) {
                  row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
                  row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
                }
              });

              alert("Code g√©n√©tique import√© avec succ√®s !");
            }

            // R√©initialiser l'input file
            event.target.value = "";
          } catch (error) {
            alert("Erreur lors de la lecture du fichier : " + error.message);
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Initialiser les mosa√Øques du bouton pixel art au chargement
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          createPixelArtMosaic();
          setupAllButtonsForMobile();
        });
      } else {
        // Le DOM est d√©j√† charg√©
        createPixelArtMosaic();
        setupAllButtonsForMobile();
      }

      // R√©appliquer la configuration des boutons apr√®s un court d√©lai pour les boutons cr√©√©s dynamiquement
      setTimeout(setupAllButtonsForMobile, 1000);
    </script>

    <!-- Raccourci clavier global : Ctrl+J pour ouvrir le dossier de t√©l√©chargements -->
    <script>
      document.addEventListener("keydown", function (e) {
        // Ctrl+J (ou Cmd+J sur Mac) pour ouvrir le dossier de t√©l√©chargements
        if ((e.ctrlKey || e.metaKey) && e.key === "j") {
          e.preventDefault();

          // Essayer d'ouvrir le dossier de t√©l√©chargements selon le navigateur
          const userAgent = navigator.userAgent.toLowerCase();

          if (userAgent.includes("chrome") || userAgent.includes("edge")) {
            // Chrome/Edge : ouvrir la page des t√©l√©chargements
            window.open("chrome://downloads", "_blank");
          } else if (userAgent.includes("firefox")) {
            // Firefox : ouvrir la page des t√©l√©chargements
            window.open("about:downloads", "_blank");
          } else if (userAgent.includes("safari")) {
            // Safari : afficher un message car on ne peut pas ouvrir directement
            alert(
              "Sur Safari, vous pouvez ouvrir le dossier de t√©l√©chargements via le menu √âdition > Afficher les t√©l√©chargements (ou Cmd+Option+L)"
            );
          } else {
            // Autres navigateurs : essayer chrome://downloads ou afficher un message
            try {
              window.open("chrome://downloads", "_blank");
            } catch (err) {
              alert(
                "Pour ouvrir le dossier de t√©l√©chargements, utilisez le raccourci de votre navigateur ou acc√©dez-y manuellement depuis le menu."
              );
            }
          }
        }
      });
    </script>
  </body>
</html>
